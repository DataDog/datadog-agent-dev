{
    "sha": "11e7861d680c3757eab18ec0a474ff680e007dc4",
    "node_id": "C_kwDOACN7MtoAKDExZTc4NjFkNjgwYzM3NTdlYWIxOGVjMGE0NzRmZjY4MGUwMDdkYzQ",
    "commit": {
        "author": {
            "name": "Linus Torvalds",
            "email": "torvalds@linux-foundation.org",
            "date": "2025-08-29T20:54:26Z"
        },
        "committer": {
            "name": "Linus Torvalds",
            "email": "torvalds@linux-foundation.org",
            "date": "2025-08-29T20:54:26Z"
        },
        "message": "Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm\n\nPull kvm fixes from Paolo Bonzini:\n \"ARM:\n\n   - Correctly handle 'invariant' system registers for protected VMs\n\n   - Improved handling of VNCR data aborts, including external aborts\n\n   - Fixes for handling of FEAT_RAS for NV guests, providing a sane\n     fault context during SEA injection and preventing the use of\n     RASv1p1 fault injection hardware\n\n   - Ensure that page table destruction when a VM is destroyed gives an\n     opportunity to reschedule\n\n   - Large fix to KVM's infrastructure for managing guest context loaded\n     on the CPU, addressing issues where the output of AT emulation\n     doesn't get reflected to the guest\n\n   - Fix AT S12 emulation to actually perform stage-2 translation when\n     necessary\n\n   - Avoid attempting vLPI irqbypass when GICv4 has been explicitly\n     disabled for a VM\n\n   - Minor KVM + selftest fixes\n\n  RISC-V:\n\n   - Fix pte settings within kvm_riscv_gstage_ioremap()\n\n   - Fix comments in kvm_riscv_check_vcpu_requests()\n\n   - Fix stack overrun when setting vlenb via ONE_REG\n\n  x86:\n\n   - Use array_index_nospec() to sanitize the target vCPU ID when\n     handling PV IPIs and yields as the ID is guest-controlled.\n\n   - Drop a superfluous cpumask_empty() check when reclaiming SEV\n     memory, as the common case, by far, is that at least one CPU will\n     have entered the VM, and wbnoinvd_on_cpus_mask() will naturally\n     handle the rare case where the set of have_run_cpus is empty.\n\n  Selftests (not KVM):\n\n   - Rename the is_signed_type() macro in kselftest_harness.h to\n     is_signed_var() to fix a collision with linux/overflow.h. The\n     collision generates compiler warnings due to the two macros having\n     different meaning\"\n\n* tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (29 commits)\n  KVM: arm64: nv: Fix ATS12 handling of single-stage translation\n  KVM: arm64: Remove __vcpu_{read,write}_sys_reg_{from,to}_cpu()\n  KVM: arm64: Fix vcpu_{read,write}_sys_reg() accessors\n  KVM: arm64: Simplify sysreg access on exception delivery\n  KVM: arm64: Check for SYSREGS_ON_CPU before accessing the 32bit state\n  RISC-V: KVM: fix stack overrun when loading vlenb\n  RISC-V: KVM: Correct kvm_riscv_check_vcpu_requests() comment\n  RISC-V: KVM: Fix pte settings within kvm_riscv_gstage_ioremap()\n  KVM: arm64: selftests: Sync ID_AA64MMFR3_EL1 in set_id_regs\n  KVM: arm64: Get rid of ARM64_FEATURE_MASK()\n  KVM: arm64: Make ID_AA64PFR1_EL1.RAS_frac writable\n  KVM: arm64: Make ID_AA64PFR0_EL1.RAS writable\n  KVM: arm64: Ignore HCR_EL2.FIEN set by L1 guest's EL2\n  KVM: arm64: Handle RASv1p1 registers\n  arm64: Add capability denoting FEAT_RASv1p1\n  KVM: arm64: Reschedule as needed when destroying the stage-2 page-tables\n  KVM: arm64: Split kvm_pgtable_stage2_destroy()\n  selftests: harness: Rename is_signed_type() to avoid collision with overflow.h\n  KVM: SEV: don't check have_run_cpus in sev_writeback_caches()\n  KVM: arm64: Correctly populate FAR_EL2 on nested SEA injection\n  ...",
        "tree": {
            "sha": "a0f68ff072fb1e98fa9593dfb3f25dc23ab9c502",
            "url": "https://api.github.com/repos/torvalds/linux/git/trees/a0f68ff072fb1e98fa9593dfb3f25dc23ab9c502"
        },
        "url": "https://api.github.com/repos/torvalds/linux/git/commits/11e7861d680c3757eab18ec0a474ff680e007dc4",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/torvalds/linux/commits/11e7861d680c3757eab18ec0a474ff680e007dc4",
    "html_url": "https://github.com/torvalds/linux/commit/11e7861d680c3757eab18ec0a474ff680e007dc4",
    "comments_url": "https://api.github.com/repos/torvalds/linux/commits/11e7861d680c3757eab18ec0a474ff680e007dc4/comments",
    "author": {
        "login": "torvalds",
        "id": 1024025,
        "node_id": "MDQ6VXNlcjEwMjQwMjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1024025?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/torvalds",
        "html_url": "https://github.com/torvalds",
        "followers_url": "https://api.github.com/users/torvalds/followers",
        "following_url": "https://api.github.com/users/torvalds/following{/other_user}",
        "gists_url": "https://api.github.com/users/torvalds/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/torvalds/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/torvalds/subscriptions",
        "organizations_url": "https://api.github.com/users/torvalds/orgs",
        "repos_url": "https://api.github.com/users/torvalds/repos",
        "events_url": "https://api.github.com/users/torvalds/events{/privacy}",
        "received_events_url": "https://api.github.com/users/torvalds/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "torvalds",
        "id": 1024025,
        "node_id": "MDQ6VXNlcjEwMjQwMjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1024025?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/torvalds",
        "html_url": "https://github.com/torvalds",
        "followers_url": "https://api.github.com/users/torvalds/followers",
        "following_url": "https://api.github.com/users/torvalds/following{/other_user}",
        "gists_url": "https://api.github.com/users/torvalds/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/torvalds/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/torvalds/subscriptions",
        "organizations_url": "https://api.github.com/users/torvalds/orgs",
        "repos_url": "https://api.github.com/users/torvalds/repos",
        "events_url": "https://api.github.com/users/torvalds/events{/privacy}",
        "received_events_url": "https://api.github.com/users/torvalds/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "fb679c832b6497f19fffb8274c419783909c0912",
            "url": "https://api.github.com/repos/torvalds/linux/commits/fb679c832b6497f19fffb8274c419783909c0912",
            "html_url": "https://github.com/torvalds/linux/commit/fb679c832b6497f19fffb8274c419783909c0912"
        },
        {
            "sha": "42a0305ab114975dbad3fe9efea06976dd62d381",
            "url": "https://api.github.com/repos/torvalds/linux/commits/42a0305ab114975dbad3fe9efea06976dd62d381",
            "html_url": "https://github.com/torvalds/linux/commit/42a0305ab114975dbad3fe9efea06976dd62d381"
        }
    ],
    "stats": {
        "total": 941,
        "additions": 579,
        "deletions": 362
    },
    "files": [
        {
            "sha": "2b07f0a27a7d85463851a4e42b01eb01c4c7e82e",
            "filename": "arch/arm64/include/asm/kvm_host.h",
            "status": "modified",
            "additions": 2,
            "deletions": 109,
            "changes": 111,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_host.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_host.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fkvm_host.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1160,115 +1160,8 @@ u64 kvm_vcpu_apply_reg_masks(const struct kvm_vcpu *, enum vcpu_sysreg, u64);\n \t\t__v;\t\t\t\t\t\t\t\\\n \t})\n \n-u64 vcpu_read_sys_reg(const struct kvm_vcpu *vcpu, int reg);\n-void vcpu_write_sys_reg(struct kvm_vcpu *vcpu, u64 val, int reg);\n-\n-static inline bool __vcpu_read_sys_reg_from_cpu(int reg, u64 *val)\n-{\n-\t/*\n-\t * *** VHE ONLY ***\n-\t *\n-\t * System registers listed in the switch are not saved on every\n-\t * exit from the guest but are only saved on vcpu_put.\n-\t *\n-\t * SYSREGS_ON_CPU *MUST* be checked before using this helper.\n-\t *\n-\t * Note that MPIDR_EL1 for the guest is set by KVM via VMPIDR_EL2 but\n-\t * should never be listed below, because the guest cannot modify its\n-\t * own MPIDR_EL1 and MPIDR_EL1 is accessed for VCPU A from VCPU B's\n-\t * thread when emulating cross-VCPU communication.\n-\t */\n-\tif (!has_vhe())\n-\t\treturn false;\n-\n-\tswitch (reg) {\n-\tcase SCTLR_EL1:\t\t*val = read_sysreg_s(SYS_SCTLR_EL12);\tbreak;\n-\tcase CPACR_EL1:\t\t*val = read_sysreg_s(SYS_CPACR_EL12);\tbreak;\n-\tcase TTBR0_EL1:\t\t*val = read_sysreg_s(SYS_TTBR0_EL12);\tbreak;\n-\tcase TTBR1_EL1:\t\t*val = read_sysreg_s(SYS_TTBR1_EL12);\tbreak;\n-\tcase TCR_EL1:\t\t*val = read_sysreg_s(SYS_TCR_EL12);\tbreak;\n-\tcase TCR2_EL1:\t\t*val = read_sysreg_s(SYS_TCR2_EL12);\tbreak;\n-\tcase PIR_EL1:\t\t*val = read_sysreg_s(SYS_PIR_EL12);\tbreak;\n-\tcase PIRE0_EL1:\t\t*val = read_sysreg_s(SYS_PIRE0_EL12);\tbreak;\n-\tcase POR_EL1:\t\t*val = read_sysreg_s(SYS_POR_EL12);\tbreak;\n-\tcase ESR_EL1:\t\t*val = read_sysreg_s(SYS_ESR_EL12);\tbreak;\n-\tcase AFSR0_EL1:\t\t*val = read_sysreg_s(SYS_AFSR0_EL12);\tbreak;\n-\tcase AFSR1_EL1:\t\t*val = read_sysreg_s(SYS_AFSR1_EL12);\tbreak;\n-\tcase FAR_EL1:\t\t*val = read_sysreg_s(SYS_FAR_EL12);\tbreak;\n-\tcase MAIR_EL1:\t\t*val = read_sysreg_s(SYS_MAIR_EL12);\tbreak;\n-\tcase VBAR_EL1:\t\t*val = read_sysreg_s(SYS_VBAR_EL12);\tbreak;\n-\tcase CONTEXTIDR_EL1:\t*val = read_sysreg_s(SYS_CONTEXTIDR_EL12);break;\n-\tcase TPIDR_EL0:\t\t*val = read_sysreg_s(SYS_TPIDR_EL0);\tbreak;\n-\tcase TPIDRRO_EL0:\t*val = read_sysreg_s(SYS_TPIDRRO_EL0);\tbreak;\n-\tcase TPIDR_EL1:\t\t*val = read_sysreg_s(SYS_TPIDR_EL1);\tbreak;\n-\tcase AMAIR_EL1:\t\t*val = read_sysreg_s(SYS_AMAIR_EL12);\tbreak;\n-\tcase CNTKCTL_EL1:\t*val = read_sysreg_s(SYS_CNTKCTL_EL12);\tbreak;\n-\tcase ELR_EL1:\t\t*val = read_sysreg_s(SYS_ELR_EL12);\tbreak;\n-\tcase SPSR_EL1:\t\t*val = read_sysreg_s(SYS_SPSR_EL12);\tbreak;\n-\tcase PAR_EL1:\t\t*val = read_sysreg_par();\t\tbreak;\n-\tcase DACR32_EL2:\t*val = read_sysreg_s(SYS_DACR32_EL2);\tbreak;\n-\tcase IFSR32_EL2:\t*val = read_sysreg_s(SYS_IFSR32_EL2);\tbreak;\n-\tcase DBGVCR32_EL2:\t*val = read_sysreg_s(SYS_DBGVCR32_EL2);\tbreak;\n-\tcase ZCR_EL1:\t\t*val = read_sysreg_s(SYS_ZCR_EL12);\tbreak;\n-\tcase SCTLR2_EL1:\t*val = read_sysreg_s(SYS_SCTLR2_EL12);\tbreak;\n-\tdefault:\t\treturn false;\n-\t}\n-\n-\treturn true;\n-}\n-\n-static inline bool __vcpu_write_sys_reg_to_cpu(u64 val, int reg)\n-{\n-\t/*\n-\t * *** VHE ONLY ***\n-\t *\n-\t * System registers listed in the switch are not restored on every\n-\t * entry to the guest but are only restored on vcpu_load.\n-\t *\n-\t * SYSREGS_ON_CPU *MUST* be checked before using this helper.\n-\t *\n-\t * Note that MPIDR_EL1 for the guest is set by KVM via VMPIDR_EL2 but\n-\t * should never be listed below, because the MPIDR should only be set\n-\t * once, before running the VCPU, and never changed later.\n-\t */\n-\tif (!has_vhe())\n-\t\treturn false;\n-\n-\tswitch (reg) {\n-\tcase SCTLR_EL1:\t\twrite_sysreg_s(val, SYS_SCTLR_EL12);\tbreak;\n-\tcase CPACR_EL1:\t\twrite_sysreg_s(val, SYS_CPACR_EL12);\tbreak;\n-\tcase TTBR0_EL1:\t\twrite_sysreg_s(val, SYS_TTBR0_EL12);\tbreak;\n-\tcase TTBR1_EL1:\t\twrite_sysreg_s(val, SYS_TTBR1_EL12);\tbreak;\n-\tcase TCR_EL1:\t\twrite_sysreg_s(val, SYS_TCR_EL12);\tbreak;\n-\tcase TCR2_EL1:\t\twrite_sysreg_s(val, SYS_TCR2_EL12);\tbreak;\n-\tcase PIR_EL1:\t\twrite_sysreg_s(val, SYS_PIR_EL12);\tbreak;\n-\tcase PIRE0_EL1:\t\twrite_sysreg_s(val, SYS_PIRE0_EL12);\tbreak;\n-\tcase POR_EL1:\t\twrite_sysreg_s(val, SYS_POR_EL12);\tbreak;\n-\tcase ESR_EL1:\t\twrite_sysreg_s(val, SYS_ESR_EL12);\tbreak;\n-\tcase AFSR0_EL1:\t\twrite_sysreg_s(val, SYS_AFSR0_EL12);\tbreak;\n-\tcase AFSR1_EL1:\t\twrite_sysreg_s(val, SYS_AFSR1_EL12);\tbreak;\n-\tcase FAR_EL1:\t\twrite_sysreg_s(val, SYS_FAR_EL12);\tbreak;\n-\tcase MAIR_EL1:\t\twrite_sysreg_s(val, SYS_MAIR_EL12);\tbreak;\n-\tcase VBAR_EL1:\t\twrite_sysreg_s(val, SYS_VBAR_EL12);\tbreak;\n-\tcase CONTEXTIDR_EL1:\twrite_sysreg_s(val, SYS_CONTEXTIDR_EL12);break;\n-\tcase TPIDR_EL0:\t\twrite_sysreg_s(val, SYS_TPIDR_EL0);\tbreak;\n-\tcase TPIDRRO_EL0:\twrite_sysreg_s(val, SYS_TPIDRRO_EL0);\tbreak;\n-\tcase TPIDR_EL1:\t\twrite_sysreg_s(val, SYS_TPIDR_EL1);\tbreak;\n-\tcase AMAIR_EL1:\t\twrite_sysreg_s(val, SYS_AMAIR_EL12);\tbreak;\n-\tcase CNTKCTL_EL1:\twrite_sysreg_s(val, SYS_CNTKCTL_EL12);\tbreak;\n-\tcase ELR_EL1:\t\twrite_sysreg_s(val, SYS_ELR_EL12);\tbreak;\n-\tcase SPSR_EL1:\t\twrite_sysreg_s(val, SYS_SPSR_EL12);\tbreak;\n-\tcase PAR_EL1:\t\twrite_sysreg_s(val, SYS_PAR_EL1);\tbreak;\n-\tcase DACR32_EL2:\twrite_sysreg_s(val, SYS_DACR32_EL2);\tbreak;\n-\tcase IFSR32_EL2:\twrite_sysreg_s(val, SYS_IFSR32_EL2);\tbreak;\n-\tcase DBGVCR32_EL2:\twrite_sysreg_s(val, SYS_DBGVCR32_EL2);\tbreak;\n-\tcase ZCR_EL1:\t\twrite_sysreg_s(val, SYS_ZCR_EL12);\tbreak;\n-\tcase SCTLR2_EL1:\twrite_sysreg_s(val, SYS_SCTLR2_EL12);\tbreak;\n-\tdefault:\t\treturn false;\n-\t}\n-\n-\treturn true;\n-}\n+u64 vcpu_read_sys_reg(const struct kvm_vcpu *, enum vcpu_sysreg);\n+void vcpu_write_sys_reg(struct kvm_vcpu *, u64, enum vcpu_sysreg);\n \n struct kvm_vm_stat {\n \tstruct kvm_vm_stat_generic generic;"
        },
        {
            "sha": "e4069f2ce64232616688a2e67e4ac4b93f71bffb",
            "filename": "arch/arm64/include/asm/kvm_mmu.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_mmu.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_mmu.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fkvm_mmu.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -180,6 +180,7 @@ void kvm_free_stage2_pgd(struct kvm_s2_mmu *mmu);\n int kvm_phys_addr_ioremap(struct kvm *kvm, phys_addr_t guest_ipa,\n \t\t\t  phys_addr_t pa, unsigned long size, bool writable);\n \n+int kvm_handle_guest_sea(struct kvm_vcpu *vcpu);\n int kvm_handle_guest_abort(struct kvm_vcpu *vcpu);\n \n phys_addr_t kvm_mmu_get_httbr(void);"
        },
        {
            "sha": "1246216616b518ec2d35992c12a48a5ae4449568",
            "filename": "arch/arm64/include/asm/kvm_pgtable.h",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pgtable.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pgtable.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pgtable.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -355,6 +355,11 @@ static inline kvm_pte_t *kvm_dereference_pteref(struct kvm_pgtable_walker *walke\n \treturn pteref;\n }\n \n+static inline kvm_pte_t *kvm_dereference_pteref_raw(kvm_pteref_t pteref)\n+{\n+\treturn pteref;\n+}\n+\n static inline int kvm_pgtable_walk_begin(struct kvm_pgtable_walker *walker)\n {\n \t/*\n@@ -384,6 +389,11 @@ static inline kvm_pte_t *kvm_dereference_pteref(struct kvm_pgtable_walker *walke\n \treturn rcu_dereference_check(pteref, !(walker->flags & KVM_PGTABLE_WALK_SHARED));\n }\n \n+static inline kvm_pte_t *kvm_dereference_pteref_raw(kvm_pteref_t pteref)\n+{\n+\treturn rcu_dereference_raw(pteref);\n+}\n+\n static inline int kvm_pgtable_walk_begin(struct kvm_pgtable_walker *walker)\n {\n \tif (walker->flags & KVM_PGTABLE_WALK_SHARED)\n@@ -551,6 +561,26 @@ static inline int kvm_pgtable_stage2_init(struct kvm_pgtable *pgt, struct kvm_s2\n  */\n void kvm_pgtable_stage2_destroy(struct kvm_pgtable *pgt);\n \n+/**\n+ * kvm_pgtable_stage2_destroy_range() - Destroy the unlinked range of addresses.\n+ * @pgt:\tPage-table structure initialised by kvm_pgtable_stage2_init*().\n+ * @addr:      Intermediate physical address at which to place the mapping.\n+ * @size:      Size of the mapping.\n+ *\n+ * The page-table is assumed to be unreachable by any hardware walkers prior\n+ * to freeing and therefore no TLB invalidation is performed.\n+ */\n+void kvm_pgtable_stage2_destroy_range(struct kvm_pgtable *pgt,\n+\t\t\t\t\tu64 addr, u64 size);\n+\n+/**\n+ * kvm_pgtable_stage2_destroy_pgd() - Destroy the PGD of guest stage-2 page-table.\n+ * @pgt:       Page-table structure initialised by kvm_pgtable_stage2_init*().\n+ *\n+ * It is assumed that the rest of the page-table is freed before this operation.\n+ */\n+void kvm_pgtable_stage2_destroy_pgd(struct kvm_pgtable *pgt);\n+\n /**\n  * kvm_pgtable_stage2_free_unlinked() - Free an unlinked stage-2 paging structure.\n  * @mm_ops:\tMemory management callbacks."
        },
        {
            "sha": "35f9d94780048c606c3717cb7a3295f9a695f2e9",
            "filename": "arch/arm64/include/asm/kvm_pkvm.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pkvm.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pkvm.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fkvm_pkvm.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -179,7 +179,9 @@ struct pkvm_mapping {\n \n int pkvm_pgtable_stage2_init(struct kvm_pgtable *pgt, struct kvm_s2_mmu *mmu,\n \t\t\t     struct kvm_pgtable_mm_ops *mm_ops);\n-void pkvm_pgtable_stage2_destroy(struct kvm_pgtable *pgt);\n+void pkvm_pgtable_stage2_destroy_range(struct kvm_pgtable *pgt,\n+\t\t\t\t\tu64 addr, u64 size);\n+void pkvm_pgtable_stage2_destroy_pgd(struct kvm_pgtable *pgt);\n int pkvm_pgtable_stage2_map(struct kvm_pgtable *pgt, u64 addr, u64 size, u64 phys,\n \t\t\t    enum kvm_pgtable_prot prot, void *mc,\n \t\t\t    enum kvm_pgtable_walk_flags flags);"
        },
        {
            "sha": "9398ade632aaf99945c13aa288fb9769658bfe46",
            "filename": "arch/arm64/include/asm/kvm_ras.h",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/torvalds/linux/blob/fb679c832b6497f19fffb8274c419783909c0912/arch%2Farm64%2Finclude%2Fasm%2Fkvm_ras.h",
            "raw_url": "https://github.com/torvalds/linux/raw/fb679c832b6497f19fffb8274c419783909c0912/arch%2Farm64%2Finclude%2Fasm%2Fkvm_ras.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fkvm_ras.h?ref=fb679c832b6497f19fffb8274c419783909c0912",
            "patch": "@@ -1,25 +0,0 @@\n-/* SPDX-License-Identifier: GPL-2.0 */\n-/* Copyright (C) 2018 - Arm Ltd */\n-\n-#ifndef __ARM64_KVM_RAS_H__\n-#define __ARM64_KVM_RAS_H__\n-\n-#include <linux/acpi.h>\n-#include <linux/errno.h>\n-#include <linux/types.h>\n-\n-#include <asm/acpi.h>\n-\n-/*\n- * Was this synchronous external abort a RAS notification?\n- * Returns '0' for errors handled by some RAS subsystem, or -ENOENT.\n- */\n-static inline int kvm_handle_guest_sea(void)\n-{\n-\t/* apei_claim_sea(NULL) expects to mask interrupts itself */\n-\tlockdep_assert_irqs_enabled();\n-\n-\treturn apei_claim_sea(NULL);\n-}\n-\n-#endif /* __ARM64_KVM_RAS_H__ */"
        },
        {
            "sha": "6604fd6f33f452389467c9a20a9565ada9acafe1",
            "filename": "arch/arm64/include/asm/sysreg.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fsysreg.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Finclude%2Fasm%2Fsysreg.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Finclude%2Fasm%2Fsysreg.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1142,9 +1142,6 @@\n \n #define ARM64_FEATURE_FIELD_BITS\t4\n \n-/* Defined for compatibility only, do not add new users. */\n-#define ARM64_FEATURE_MASK(x)\t(x##_MASK)\n-\n #ifdef __ASSEMBLY__\n \n \t.macro\tmrs_s, rt, sreg"
        },
        {
            "sha": "0d45c5e9b4da5a2a54e8c85cd8650d54c928b624",
            "filename": "arch/arm64/kernel/cpufeature.c",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkernel%2Fcpufeature.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkernel%2Fcpufeature.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkernel%2Fcpufeature.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -2269,6 +2269,24 @@ static void cpu_clear_disr(const struct arm64_cpu_capabilities *__unused)\n \t/* Firmware may have left a deferred SError in this register. */\n \twrite_sysreg_s(0, SYS_DISR_EL1);\n }\n+static bool has_rasv1p1(const struct arm64_cpu_capabilities *__unused, int scope)\n+{\n+\tconst struct arm64_cpu_capabilities rasv1p1_caps[] = {\n+\t\t{\n+\t\t\tARM64_CPUID_FIELDS(ID_AA64PFR0_EL1, RAS, V1P1)\n+\t\t},\n+\t\t{\n+\t\t\tARM64_CPUID_FIELDS(ID_AA64PFR0_EL1, RAS, IMP)\n+\t\t},\n+\t\t{\n+\t\t\tARM64_CPUID_FIELDS(ID_AA64PFR1_EL1, RAS_frac, RASv1p1)\n+\t\t},\n+\t};\n+\n+\treturn (has_cpuid_feature(&rasv1p1_caps[0], scope) ||\n+\t\t(has_cpuid_feature(&rasv1p1_caps[1], scope) &&\n+\t\t has_cpuid_feature(&rasv1p1_caps[2], scope)));\n+}\n #endif /* CONFIG_ARM64_RAS_EXTN */\n \n #ifdef CONFIG_ARM64_PTR_AUTH\n@@ -2687,6 +2705,12 @@ static const struct arm64_cpu_capabilities arm64_features[] = {\n \t\t.cpu_enable = cpu_clear_disr,\n \t\tARM64_CPUID_FIELDS(ID_AA64PFR0_EL1, RAS, IMP)\n \t},\n+\t{\n+\t\t.desc = \"RASv1p1 Extension Support\",\n+\t\t.capability = ARM64_HAS_RASV1P1_EXTN,\n+\t\t.type = ARM64_CPUCAP_SYSTEM_FEATURE,\n+\t\t.matches = has_rasv1p1,\n+\t},\n #endif /* CONFIG_ARM64_RAS_EXTN */\n #ifdef CONFIG_ARM64_AMU_EXTN\n \t{"
        },
        {
            "sha": "5bf101c869c9ab179ebf0672b42b37fe2eec1bc5",
            "filename": "arch/arm64/kvm/arm.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Farm.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Farm.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Farm.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -2408,12 +2408,12 @@ static u64 get_hyp_id_aa64pfr0_el1(void)\n \t */\n \tu64 val = read_sanitised_ftr_reg(SYS_ID_AA64PFR0_EL1);\n \n-\tval &= ~(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_CSV2) |\n-\t\t ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_CSV3));\n+\tval &= ~(ID_AA64PFR0_EL1_CSV2 |\n+\t\t ID_AA64PFR0_EL1_CSV3);\n \n-\tval |= FIELD_PREP(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_CSV2),\n+\tval |= FIELD_PREP(ID_AA64PFR0_EL1_CSV2,\n \t\t\t  arm64_get_spectre_v2_state() == SPECTRE_UNAFFECTED);\n-\tval |= FIELD_PREP(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_CSV3),\n+\tval |= FIELD_PREP(ID_AA64PFR0_EL1_CSV3,\n \t\t\t  arm64_get_meltdown_state() == SPECTRE_UNAFFECTED);\n \n \treturn val;"
        },
        {
            "sha": "d71ca4ddc9d1e522b9e05e685f89b3c95ba41516",
            "filename": "arch/arm64/kvm/at.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fat.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fat.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fat.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1420,10 +1420,10 @@ void __kvm_at_s12(struct kvm_vcpu *vcpu, u32 op, u64 vaddr)\n \t\treturn;\n \n \t/*\n-\t * If we only have a single stage of translation (E2H=0 or\n-\t * TGE=1), exit early. Same thing if {VM,DC}=={0,0}.\n+\t * If we only have a single stage of translation (EL2&0), exit\n+\t * early. Same thing if {VM,DC}=={0,0}.\n \t */\n-\tif (!vcpu_el2_e2h_is_set(vcpu) || vcpu_el2_tge_is_set(vcpu) ||\n+\tif (compute_translation_regime(vcpu, op) == TR_EL20 ||\n \t    !(vcpu_read_sys_reg(vcpu, HCR_EL2) & (HCR_VM | HCR_DC)))\n \t\treturn;\n "
        },
        {
            "sha": "af69c897c2c3adb1b8ae7fdebe2c1a162ca13327",
            "filename": "arch/arm64/kvm/emulate-nested.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Femulate-nested.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Femulate-nested.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Femulate-nested.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -2833,7 +2833,7 @@ int kvm_inject_nested_sea(struct kvm_vcpu *vcpu, bool iabt, u64 addr)\n \t\t\t     iabt ? ESR_ELx_EC_IABT_LOW : ESR_ELx_EC_DABT_LOW);\n \tesr |= ESR_ELx_FSC_EXTABT | ESR_ELx_IL;\n \n-\tvcpu_write_sys_reg(vcpu, FAR_EL2, addr);\n+\tvcpu_write_sys_reg(vcpu, addr, FAR_EL2);\n \n \tif (__vcpu_sys_reg(vcpu, SCTLR2_EL2) & SCTLR2_EL1_EASE)\n \t\treturn kvm_inject_nested(vcpu, esr, except_type_serror);"
        },
        {
            "sha": "bef40ddb16dbc2668be0daa5fdfc3aed87ba6bdd",
            "filename": "arch/arm64/kvm/hyp/exception.c",
            "status": "modified",
            "additions": 6,
            "deletions": 14,
            "changes": 20,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fexception.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fexception.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fexception.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -22,52 +22,44 @@\n \n static inline u64 __vcpu_read_sys_reg(const struct kvm_vcpu *vcpu, int reg)\n {\n-\tu64 val;\n-\n-\tif (unlikely(vcpu_has_nv(vcpu)))\n+\tif (has_vhe())\n \t\treturn vcpu_read_sys_reg(vcpu, reg);\n-\telse if (vcpu_get_flag(vcpu, SYSREGS_ON_CPU) &&\n-\t\t __vcpu_read_sys_reg_from_cpu(reg, &val))\n-\t\treturn val;\n \n \treturn __vcpu_sys_reg(vcpu, reg);\n }\n \n static inline void __vcpu_write_sys_reg(struct kvm_vcpu *vcpu, u64 val, int reg)\n {\n-\tif (unlikely(vcpu_has_nv(vcpu)))\n+\tif (has_vhe())\n \t\tvcpu_write_sys_reg(vcpu, val, reg);\n-\telse if (!vcpu_get_flag(vcpu, SYSREGS_ON_CPU) ||\n-\t\t !__vcpu_write_sys_reg_to_cpu(val, reg))\n+\telse\n \t\t__vcpu_assign_sys_reg(vcpu, reg, val);\n }\n \n static void __vcpu_write_spsr(struct kvm_vcpu *vcpu, unsigned long target_mode,\n \t\t\t      u64 val)\n {\n-\tif (unlikely(vcpu_has_nv(vcpu))) {\n+\tif (has_vhe()) {\n \t\tif (target_mode == PSR_MODE_EL1h)\n \t\t\tvcpu_write_sys_reg(vcpu, val, SPSR_EL1);\n \t\telse\n \t\t\tvcpu_write_sys_reg(vcpu, val, SPSR_EL2);\n-\t} else if (has_vhe()) {\n-\t\twrite_sysreg_el1(val, SYS_SPSR);\n \t} else {\n \t\t__vcpu_assign_sys_reg(vcpu, SPSR_EL1, val);\n \t}\n }\n \n static void __vcpu_write_spsr_abt(struct kvm_vcpu *vcpu, u64 val)\n {\n-\tif (has_vhe())\n+\tif (has_vhe() && vcpu_get_flag(vcpu, SYSREGS_ON_CPU))\n \t\twrite_sysreg(val, spsr_abt);\n \telse\n \t\tvcpu->arch.ctxt.spsr_abt = val;\n }\n \n static void __vcpu_write_spsr_und(struct kvm_vcpu *vcpu, u64 val)\n {\n-\tif (has_vhe())\n+\tif (has_vhe() && vcpu_get_flag(vcpu, SYSREGS_ON_CPU))\n \t\twrite_sysreg(val, spsr_und);\n \telse\n \t\tvcpu->arch.ctxt.spsr_und = val;"
        },
        {
            "sha": "baa6260f88dc13762c0e1f16870a64903d4c8e19",
            "filename": "arch/arm64/kvm/hyp/nvhe/list_debug.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Flist_debug.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Flist_debug.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Flist_debug.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -17,7 +17,7 @@ static inline __must_check bool nvhe_check_data_corruption(bool v)\n \t\tbool corruption = unlikely(condition);\t\t\t \\\n \t\tif (corruption) {\t\t\t\t\t \\\n \t\t\tif (IS_ENABLED(CONFIG_BUG_ON_DATA_CORRUPTION)) { \\\n-\t\t\t\tBUG_ON(1);\t\t\t\t \\\n+\t\t\t\tBUG();\t\t\t\t \t \\\n \t\t\t} else\t\t\t\t\t\t \\\n \t\t\t\tWARN_ON(1);\t\t\t\t \\\n \t\t}\t\t\t\t\t\t\t \\"
        },
        {
            "sha": "71d2fc97f0046a777b2e785b5cb2f6c188e183e4",
            "filename": "arch/arm64/kvm/hyp/nvhe/sys_regs.c",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Fsys_regs.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Fsys_regs.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fnvhe%2Fsys_regs.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -253,6 +253,7 @@ static void inject_undef64(struct kvm_vcpu *vcpu)\n \n \t*vcpu_pc(vcpu) = read_sysreg_el2(SYS_ELR);\n \t*vcpu_cpsr(vcpu) = read_sysreg_el2(SYS_SPSR);\n+\t__vcpu_assign_sys_reg(vcpu, read_sysreg_el1(SYS_VBAR), VBAR_EL1);\n \n \tkvm_pend_exception(vcpu, EXCEPT_AA64_EL1_SYNC);\n \n@@ -372,6 +373,9 @@ static const struct sys_reg_desc pvm_sys_reg_descs[] = {\n \n \t/* Debug and Trace Registers are restricted. */\n \n+\t/* Group 1 ID registers */\n+\tHOST_HANDLED(SYS_REVIDR_EL1),\n+\n \t/* AArch64 mappings of the AArch32 ID registers */\n \t/* CRm=1 */\n \tAARCH32(SYS_ID_PFR0_EL1),\n@@ -460,6 +464,7 @@ static const struct sys_reg_desc pvm_sys_reg_descs[] = {\n \n \tHOST_HANDLED(SYS_CCSIDR_EL1),\n \tHOST_HANDLED(SYS_CLIDR_EL1),\n+\tHOST_HANDLED(SYS_AIDR_EL1),\n \tHOST_HANDLED(SYS_CSSELR_EL1),\n \tHOST_HANDLED(SYS_CTR_EL0),\n "
        },
        {
            "sha": "c36f282a175dfc336a83ee913726de90194ad5cb",
            "filename": "arch/arm64/kvm/hyp/pgtable.c",
            "status": "modified",
            "additions": 21,
            "deletions": 4,
            "changes": 25,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fpgtable.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fpgtable.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fpgtable.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1551,21 +1551,38 @@ static int stage2_free_walker(const struct kvm_pgtable_visit_ctx *ctx,\n \treturn 0;\n }\n \n-void kvm_pgtable_stage2_destroy(struct kvm_pgtable *pgt)\n+void kvm_pgtable_stage2_destroy_range(struct kvm_pgtable *pgt,\n+\t\t\t\t       u64 addr, u64 size)\n {\n-\tsize_t pgd_sz;\n \tstruct kvm_pgtable_walker walker = {\n \t\t.cb\t= stage2_free_walker,\n \t\t.flags\t= KVM_PGTABLE_WALK_LEAF |\n \t\t\t  KVM_PGTABLE_WALK_TABLE_POST,\n \t};\n \n-\tWARN_ON(kvm_pgtable_walk(pgt, 0, BIT(pgt->ia_bits), &walker));\n+\tWARN_ON(kvm_pgtable_walk(pgt, addr, size, &walker));\n+}\n+\n+void kvm_pgtable_stage2_destroy_pgd(struct kvm_pgtable *pgt)\n+{\n+\tsize_t pgd_sz;\n+\n \tpgd_sz = kvm_pgd_pages(pgt->ia_bits, pgt->start_level) * PAGE_SIZE;\n-\tpgt->mm_ops->free_pages_exact(kvm_dereference_pteref(&walker, pgt->pgd), pgd_sz);\n+\n+\t/*\n+\t * Since the pgtable is unlinked at this point, and not shared with\n+\t * other walkers, safely deference pgd with kvm_dereference_pteref_raw()\n+\t */\n+\tpgt->mm_ops->free_pages_exact(kvm_dereference_pteref_raw(pgt->pgd), pgd_sz);\n \tpgt->pgd = NULL;\n }\n \n+void kvm_pgtable_stage2_destroy(struct kvm_pgtable *pgt)\n+{\n+\tkvm_pgtable_stage2_destroy_range(pgt, 0, BIT(pgt->ia_bits));\n+\tkvm_pgtable_stage2_destroy_pgd(pgt);\n+}\n+\n void kvm_pgtable_stage2_free_unlinked(struct kvm_pgtable_mm_ops *mm_ops, void *pgtable, s8 level)\n {\n \tkvm_pteref_t ptep = (kvm_pteref_t)pgtable;"
        },
        {
            "sha": "78579b31a4205fe1e8877f3da172faddacb4b42f",
            "filename": "arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fvgic-v2-cpuif-proxy.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fvgic-v2-cpuif-proxy.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fvgic-v2-cpuif-proxy.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -20,7 +20,7 @@ static bool __is_be(struct kvm_vcpu *vcpu)\n \tif (vcpu_mode_is_32bit(vcpu))\n \t\treturn !!(read_sysreg_el2(SYS_SPSR) & PSR_AA32_E_BIT);\n \n-\treturn !!(read_sysreg(SCTLR_EL1) & SCTLR_ELx_EE);\n+\treturn !!(read_sysreg_el1(SYS_SCTLR) & SCTLR_ELx_EE);\n }\n \n /*"
        },
        {
            "sha": "0998ad4a25524f673c6f513c7d721448847302c1",
            "filename": "arch/arm64/kvm/hyp/vhe/switch.c",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fvhe%2Fswitch.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fhyp%2Fvhe%2Fswitch.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fhyp%2Fvhe%2Fswitch.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -43,8 +43,11 @@ DEFINE_PER_CPU(unsigned long, kvm_hyp_vector);\n  *\n  * - API/APK: they are already accounted for by vcpu_load(), and can\n  *   only take effect across a load/put cycle (such as ERET)\n+ *\n+ * - FIEN: no way we let a guest have access to the RAS \"Common Fault\n+ *   Injection\" thing, whatever that does\n  */\n-#define NV_HCR_GUEST_EXCLUDE\t(HCR_TGE | HCR_API | HCR_APK)\n+#define NV_HCR_GUEST_EXCLUDE\t(HCR_TGE | HCR_API | HCR_APK | HCR_FIEN)\n \n static u64 __compute_hcr(struct kvm_vcpu *vcpu)\n {"
        },
        {
            "sha": "86f3d80daf37aff30e41ee0f244b0499acae3d2d",
            "filename": "arch/arm64/kvm/mmu.c",
            "status": "modified",
            "additions": 51,
            "deletions": 14,
            "changes": 65,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fmmu.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fmmu.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fmmu.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -4,19 +4,20 @@\n  * Author: Christoffer Dall <c.dall@virtualopensystems.com>\n  */\n \n+#include <linux/acpi.h>\n #include <linux/mman.h>\n #include <linux/kvm_host.h>\n #include <linux/io.h>\n #include <linux/hugetlb.h>\n #include <linux/sched/signal.h>\n #include <trace/events/kvm.h>\n+#include <asm/acpi.h>\n #include <asm/pgalloc.h>\n #include <asm/cacheflush.h>\n #include <asm/kvm_arm.h>\n #include <asm/kvm_mmu.h>\n #include <asm/kvm_pgtable.h>\n #include <asm/kvm_pkvm.h>\n-#include <asm/kvm_ras.h>\n #include <asm/kvm_asm.h>\n #include <asm/kvm_emulate.h>\n #include <asm/virt.h>\n@@ -903,6 +904,38 @@ static int kvm_init_ipa_range(struct kvm_s2_mmu *mmu, unsigned long type)\n \treturn 0;\n }\n \n+/*\n+ * Assume that @pgt is valid and unlinked from the KVM MMU to free the\n+ * page-table without taking the kvm_mmu_lock and without performing any\n+ * TLB invalidations.\n+ *\n+ * Also, the range of addresses can be large enough to cause need_resched\n+ * warnings, for instance on CONFIG_PREEMPT_NONE kernels. Hence, invoke\n+ * cond_resched() periodically to prevent hogging the CPU for a long time\n+ * and schedule something else, if required.\n+ */\n+static void stage2_destroy_range(struct kvm_pgtable *pgt, phys_addr_t addr,\n+\t\t\t\t   phys_addr_t end)\n+{\n+\tu64 next;\n+\n+\tdo {\n+\t\tnext = stage2_range_addr_end(addr, end);\n+\t\tKVM_PGT_FN(kvm_pgtable_stage2_destroy_range)(pgt, addr,\n+\t\t\t\t\t\t\t\tnext - addr);\n+\t\tif (next != end)\n+\t\t\tcond_resched();\n+\t} while (addr = next, addr != end);\n+}\n+\n+static void kvm_stage2_destroy(struct kvm_pgtable *pgt)\n+{\n+\tunsigned int ia_bits = VTCR_EL2_IPA(pgt->mmu->vtcr);\n+\n+\tstage2_destroy_range(pgt, 0, BIT(ia_bits));\n+\tKVM_PGT_FN(kvm_pgtable_stage2_destroy_pgd)(pgt);\n+}\n+\n /**\n  * kvm_init_stage2_mmu - Initialise a S2 MMU structure\n  * @kvm:\tThe pointer to the KVM structure\n@@ -979,7 +1012,7 @@ int kvm_init_stage2_mmu(struct kvm *kvm, struct kvm_s2_mmu *mmu, unsigned long t\n \treturn 0;\n \n out_destroy_pgtable:\n-\tKVM_PGT_FN(kvm_pgtable_stage2_destroy)(pgt);\n+\tkvm_stage2_destroy(pgt);\n out_free_pgtable:\n \tkfree(pgt);\n \treturn err;\n@@ -1076,7 +1109,7 @@ void kvm_free_stage2_pgd(struct kvm_s2_mmu *mmu)\n \twrite_unlock(&kvm->mmu_lock);\n \n \tif (pgt) {\n-\t\tKVM_PGT_FN(kvm_pgtable_stage2_destroy)(pgt);\n+\t\tkvm_stage2_destroy(pgt);\n \t\tkfree(pgt);\n \t}\n }\n@@ -1811,6 +1844,19 @@ static void handle_access_fault(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa)\n \tread_unlock(&vcpu->kvm->mmu_lock);\n }\n \n+int kvm_handle_guest_sea(struct kvm_vcpu *vcpu)\n+{\n+\t/*\n+\t * Give APEI the opportunity to claim the abort before handling it\n+\t * within KVM. apei_claim_sea() expects to be called with IRQs enabled.\n+\t */\n+\tlockdep_assert_irqs_enabled();\n+\tif (apei_claim_sea(NULL) == 0)\n+\t\treturn 1;\n+\n+\treturn kvm_inject_serror(vcpu);\n+}\n+\n /**\n  * kvm_handle_guest_abort - handles all 2nd stage aborts\n  * @vcpu:\tthe VCPU pointer\n@@ -1834,17 +1880,8 @@ int kvm_handle_guest_abort(struct kvm_vcpu *vcpu)\n \tgfn_t gfn;\n \tint ret, idx;\n \n-\t/* Synchronous External Abort? */\n-\tif (kvm_vcpu_abt_issea(vcpu)) {\n-\t\t/*\n-\t\t * For RAS the host kernel may handle this abort.\n-\t\t * There is no need to pass the error into the guest.\n-\t\t */\n-\t\tif (kvm_handle_guest_sea())\n-\t\t\treturn kvm_inject_serror(vcpu);\n-\n-\t\treturn 1;\n-\t}\n+\tif (kvm_vcpu_abt_issea(vcpu))\n+\t\treturn kvm_handle_guest_sea(vcpu);\n \n \tesr = kvm_vcpu_get_esr(vcpu);\n "
        },
        {
            "sha": "77db81bae86f9b1b4f34d63069a3bdebf03190ef",
            "filename": "arch/arm64/kvm/nested.c",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fnested.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fnested.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fnested.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1287,7 +1287,10 @@ int kvm_handle_vncr_abort(struct kvm_vcpu *vcpu)\n \tstruct vncr_tlb *vt = vcpu->arch.vncr_tlb;\n \tu64 esr = kvm_vcpu_get_esr(vcpu);\n \n-\tBUG_ON(!(esr & ESR_ELx_VNCR_SHIFT));\n+\tWARN_ON_ONCE(!(esr & ESR_ELx_VNCR));\n+\n+\tif (kvm_vcpu_abt_issea(vcpu))\n+\t\treturn kvm_handle_guest_sea(vcpu);\n \n \tif (esr_fsc_is_permission_fault(esr)) {\n \t\tinject_vncr_perm(vcpu);"
        },
        {
            "sha": "61827cf6fea4aafa926f71f5f15e50655535a8b5",
            "filename": "arch/arm64/kvm/pkvm.c",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fpkvm.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fpkvm.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fpkvm.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -316,9 +316,16 @@ static int __pkvm_pgtable_stage2_unmap(struct kvm_pgtable *pgt, u64 start, u64 e\n \treturn 0;\n }\n \n-void pkvm_pgtable_stage2_destroy(struct kvm_pgtable *pgt)\n+void pkvm_pgtable_stage2_destroy_range(struct kvm_pgtable *pgt,\n+\t\t\t\t\tu64 addr, u64 size)\n {\n-\t__pkvm_pgtable_stage2_unmap(pgt, 0, ~(0ULL));\n+\t__pkvm_pgtable_stage2_unmap(pgt, addr, addr + size);\n+}\n+\n+void pkvm_pgtable_stage2_destroy_pgd(struct kvm_pgtable *pgt)\n+{\n+\t/* Expected to be called after all pKVM mappings have been released. */\n+\tWARN_ON_ONCE(!RB_EMPTY_ROOT(&pgt->pkvm_mappings.rb_root));\n }\n \n int pkvm_pgtable_stage2_map(struct kvm_pgtable *pgt, u64 addr, u64 size,"
        },
        {
            "sha": "b29f72478a50d594f3a37ab12bbb5ed9ea901d46",
            "filename": "arch/arm64/kvm/sys_regs.c",
            "status": "modified",
            "additions": 287,
            "deletions": 132,
            "changes": 419,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fsys_regs.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fsys_regs.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fsys_regs.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -82,43 +82,105 @@ static bool write_to_read_only(struct kvm_vcpu *vcpu,\n \t\t\t\"sys_reg write to read-only register\");\n }\n \n-#define PURE_EL2_SYSREG(el2)\t\t\t\t\t\t\\\n-\tcase el2: {\t\t\t\t\t\t\t\\\n-\t\t*el1r = el2;\t\t\t\t\t\t\\\n-\t\treturn true;\t\t\t\t\t\t\\\n+enum sr_loc_attr {\n+\tSR_LOC_MEMORY\t= 0,\t  /* Register definitely in memory */\n+\tSR_LOC_LOADED\t= BIT(0), /* Register on CPU, unless it cannot */\n+\tSR_LOC_MAPPED\t= BIT(1), /* Register in a different CPU register */\n+\tSR_LOC_XLATED\t= BIT(2), /* Register translated to fit another reg */\n+\tSR_LOC_SPECIAL\t= BIT(3), /* Demanding register, implies loaded */\n+};\n+\n+struct sr_loc {\n+\tenum sr_loc_attr loc;\n+\tenum vcpu_sysreg map_reg;\n+\tu64\t\t (*xlate)(u64);\n+};\n+\n+static enum sr_loc_attr locate_direct_register(const struct kvm_vcpu *vcpu,\n+\t\t\t\t\t       enum vcpu_sysreg reg)\n+{\n+\tswitch (reg) {\n+\tcase SCTLR_EL1:\n+\tcase CPACR_EL1:\n+\tcase TTBR0_EL1:\n+\tcase TTBR1_EL1:\n+\tcase TCR_EL1:\n+\tcase TCR2_EL1:\n+\tcase PIR_EL1:\n+\tcase PIRE0_EL1:\n+\tcase POR_EL1:\n+\tcase ESR_EL1:\n+\tcase AFSR0_EL1:\n+\tcase AFSR1_EL1:\n+\tcase FAR_EL1:\n+\tcase MAIR_EL1:\n+\tcase VBAR_EL1:\n+\tcase CONTEXTIDR_EL1:\n+\tcase AMAIR_EL1:\n+\tcase CNTKCTL_EL1:\n+\tcase ELR_EL1:\n+\tcase SPSR_EL1:\n+\tcase ZCR_EL1:\n+\tcase SCTLR2_EL1:\n+\t\t/*\n+\t\t * EL1 registers which have an ELx2 mapping are loaded if\n+\t\t * we're not in hypervisor context.\n+\t\t */\n+\t\treturn is_hyp_ctxt(vcpu) ? SR_LOC_MEMORY : SR_LOC_LOADED;\n+\n+\tcase TPIDR_EL0:\n+\tcase TPIDRRO_EL0:\n+\tcase TPIDR_EL1:\n+\tcase PAR_EL1:\n+\tcase DACR32_EL2:\n+\tcase IFSR32_EL2:\n+\tcase DBGVCR32_EL2:\n+\t\t/* These registers are always loaded, no matter what */\n+\t\treturn SR_LOC_LOADED;\n+\n+\tdefault:\n+\t\t/* Non-mapped EL2 registers are by definition in memory. */\n+\t\treturn SR_LOC_MEMORY;\n \t}\n+}\n \n-#define MAPPED_EL2_SYSREG(el2, el1, fn)\t\t\t\t\t\\\n-\tcase el2: {\t\t\t\t\t\t\t\\\n-\t\t*xlate = fn;\t\t\t\t\t\t\\\n-\t\t*el1r = el1;\t\t\t\t\t\t\\\n-\t\treturn true;\t\t\t\t\t\t\\\n+static void locate_mapped_el2_register(const struct kvm_vcpu *vcpu,\n+\t\t\t\t       enum vcpu_sysreg reg,\n+\t\t\t\t       enum vcpu_sysreg map_reg,\n+\t\t\t\t       u64 (*xlate)(u64),\n+\t\t\t\t       struct sr_loc *loc)\n+{\n+\tif (!is_hyp_ctxt(vcpu)) {\n+\t\tloc->loc = SR_LOC_MEMORY;\n+\t\treturn;\n+\t}\n+\n+\tloc->loc = SR_LOC_LOADED | SR_LOC_MAPPED;\n+\tloc->map_reg = map_reg;\n+\n+\tWARN_ON(locate_direct_register(vcpu, map_reg) != SR_LOC_MEMORY);\n+\n+\tif (xlate != NULL && !vcpu_el2_e2h_is_set(vcpu)) {\n+\t\tloc->loc |= SR_LOC_XLATED;\n+\t\tloc->xlate = xlate;\n \t}\n+}\n \n-static bool get_el2_to_el1_mapping(unsigned int reg,\n-\t\t\t\t   unsigned int *el1r, u64 (**xlate)(u64))\n+#define MAPPED_EL2_SYSREG(r, m, t)\t\t\t\t\t\\\n+\tcase r:\t{\t\t\t\t\t\t\t\\\n+\t\tlocate_mapped_el2_register(vcpu, r, m, t, loc);\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\t\\\n+\t}\n+\n+static void locate_register(const struct kvm_vcpu *vcpu, enum vcpu_sysreg reg,\n+\t\t\t    struct sr_loc *loc)\n {\n+\tif (!vcpu_get_flag(vcpu, SYSREGS_ON_CPU)) {\n+\t\tloc->loc = SR_LOC_MEMORY;\n+\t\treturn;\n+\t}\n+\n \tswitch (reg) {\n-\t\tPURE_EL2_SYSREG(  VPIDR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  VMPIDR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  ACTLR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HCR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  MDCR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HSTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HACR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  VTTBR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  VTCR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  TPIDR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HPFAR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HCRX_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HFGRTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HFGWTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HFGITR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HDFGRTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HDFGWTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  HAFGRTR_EL2\t);\n-\t\tPURE_EL2_SYSREG(  CNTVOFF_EL2\t);\n-\t\tPURE_EL2_SYSREG(  CNTHCTL_EL2\t);\n \t\tMAPPED_EL2_SYSREG(SCTLR_EL2,   SCTLR_EL1,\n \t\t\t\t  translate_sctlr_el2_to_sctlr_el1\t     );\n \t\tMAPPED_EL2_SYSREG(CPTR_EL2,    CPACR_EL1,\n@@ -144,125 +206,189 @@ static bool get_el2_to_el1_mapping(unsigned int reg,\n \t\tMAPPED_EL2_SYSREG(ZCR_EL2,     ZCR_EL1,     NULL\t     );\n \t\tMAPPED_EL2_SYSREG(CONTEXTIDR_EL2, CONTEXTIDR_EL1, NULL\t     );\n \t\tMAPPED_EL2_SYSREG(SCTLR2_EL2,  SCTLR2_EL1,  NULL\t     );\n+\tcase CNTHCTL_EL2:\n+\t\t/* CNTHCTL_EL2 is super special, until we support NV2.1 */\n+\t\tloc->loc = ((is_hyp_ctxt(vcpu) && vcpu_el2_e2h_is_set(vcpu)) ?\n+\t\t\t    SR_LOC_SPECIAL : SR_LOC_MEMORY);\n+\t\tbreak;\n \tdefault:\n-\t\treturn false;\n+\t\tloc->loc = locate_direct_register(vcpu, reg);\n \t}\n }\n \n-u64 vcpu_read_sys_reg(const struct kvm_vcpu *vcpu, int reg)\n+static u64 read_sr_from_cpu(enum vcpu_sysreg reg)\n {\n \tu64 val = 0x8badf00d8badf00d;\n-\tu64 (*xlate)(u64) = NULL;\n-\tunsigned int el1r;\n \n-\tif (!vcpu_get_flag(vcpu, SYSREGS_ON_CPU))\n-\t\tgoto memory_read;\n+\tswitch (reg) {\n+\tcase SCTLR_EL1:\t\tval = read_sysreg_s(SYS_SCTLR_EL12);\tbreak;\n+\tcase CPACR_EL1:\t\tval = read_sysreg_s(SYS_CPACR_EL12);\tbreak;\n+\tcase TTBR0_EL1:\t\tval = read_sysreg_s(SYS_TTBR0_EL12);\tbreak;\n+\tcase TTBR1_EL1:\t\tval = read_sysreg_s(SYS_TTBR1_EL12);\tbreak;\n+\tcase TCR_EL1:\t\tval = read_sysreg_s(SYS_TCR_EL12);\tbreak;\n+\tcase TCR2_EL1:\t\tval = read_sysreg_s(SYS_TCR2_EL12);\tbreak;\n+\tcase PIR_EL1:\t\tval = read_sysreg_s(SYS_PIR_EL12);\tbreak;\n+\tcase PIRE0_EL1:\t\tval = read_sysreg_s(SYS_PIRE0_EL12);\tbreak;\n+\tcase POR_EL1:\t\tval = read_sysreg_s(SYS_POR_EL12);\tbreak;\n+\tcase ESR_EL1:\t\tval = read_sysreg_s(SYS_ESR_EL12);\tbreak;\n+\tcase AFSR0_EL1:\t\tval = read_sysreg_s(SYS_AFSR0_EL12);\tbreak;\n+\tcase AFSR1_EL1:\t\tval = read_sysreg_s(SYS_AFSR1_EL12);\tbreak;\n+\tcase FAR_EL1:\t\tval = read_sysreg_s(SYS_FAR_EL12);\tbreak;\n+\tcase MAIR_EL1:\t\tval = read_sysreg_s(SYS_MAIR_EL12);\tbreak;\n+\tcase VBAR_EL1:\t\tval = read_sysreg_s(SYS_VBAR_EL12);\tbreak;\n+\tcase CONTEXTIDR_EL1:\tval = read_sysreg_s(SYS_CONTEXTIDR_EL12);break;\n+\tcase AMAIR_EL1:\t\tval = read_sysreg_s(SYS_AMAIR_EL12);\tbreak;\n+\tcase CNTKCTL_EL1:\tval = read_sysreg_s(SYS_CNTKCTL_EL12);\tbreak;\n+\tcase ELR_EL1:\t\tval = read_sysreg_s(SYS_ELR_EL12);\tbreak;\n+\tcase SPSR_EL1:\t\tval = read_sysreg_s(SYS_SPSR_EL12);\tbreak;\n+\tcase ZCR_EL1:\t\tval = read_sysreg_s(SYS_ZCR_EL12);\tbreak;\n+\tcase SCTLR2_EL1:\tval = read_sysreg_s(SYS_SCTLR2_EL12);\tbreak;\n+\tcase TPIDR_EL0:\t\tval = read_sysreg_s(SYS_TPIDR_EL0);\tbreak;\n+\tcase TPIDRRO_EL0:\tval = read_sysreg_s(SYS_TPIDRRO_EL0);\tbreak;\n+\tcase TPIDR_EL1:\t\tval = read_sysreg_s(SYS_TPIDR_EL1);\tbreak;\n+\tcase PAR_EL1:\t\tval = read_sysreg_par();\t\tbreak;\n+\tcase DACR32_EL2:\tval = read_sysreg_s(SYS_DACR32_EL2);\tbreak;\n+\tcase IFSR32_EL2:\tval = read_sysreg_s(SYS_IFSR32_EL2);\tbreak;\n+\tcase DBGVCR32_EL2:\tval = read_sysreg_s(SYS_DBGVCR32_EL2);\tbreak;\n+\tdefault:\t\tWARN_ON_ONCE(1);\n+\t}\n \n-\tif (unlikely(get_el2_to_el1_mapping(reg, &el1r, &xlate))) {\n-\t\tif (!is_hyp_ctxt(vcpu))\n-\t\t\tgoto memory_read;\n+\treturn val;\n+}\n+\n+static void write_sr_to_cpu(enum vcpu_sysreg reg, u64 val)\n+{\n+\tswitch (reg) {\n+\tcase SCTLR_EL1:\t\twrite_sysreg_s(val, SYS_SCTLR_EL12);\tbreak;\n+\tcase CPACR_EL1:\t\twrite_sysreg_s(val, SYS_CPACR_EL12);\tbreak;\n+\tcase TTBR0_EL1:\t\twrite_sysreg_s(val, SYS_TTBR0_EL12);\tbreak;\n+\tcase TTBR1_EL1:\t\twrite_sysreg_s(val, SYS_TTBR1_EL12);\tbreak;\n+\tcase TCR_EL1:\t\twrite_sysreg_s(val, SYS_TCR_EL12);\tbreak;\n+\tcase TCR2_EL1:\t\twrite_sysreg_s(val, SYS_TCR2_EL12);\tbreak;\n+\tcase PIR_EL1:\t\twrite_sysreg_s(val, SYS_PIR_EL12);\tbreak;\n+\tcase PIRE0_EL1:\t\twrite_sysreg_s(val, SYS_PIRE0_EL12);\tbreak;\n+\tcase POR_EL1:\t\twrite_sysreg_s(val, SYS_POR_EL12);\tbreak;\n+\tcase ESR_EL1:\t\twrite_sysreg_s(val, SYS_ESR_EL12);\tbreak;\n+\tcase AFSR0_EL1:\t\twrite_sysreg_s(val, SYS_AFSR0_EL12);\tbreak;\n+\tcase AFSR1_EL1:\t\twrite_sysreg_s(val, SYS_AFSR1_EL12);\tbreak;\n+\tcase FAR_EL1:\t\twrite_sysreg_s(val, SYS_FAR_EL12);\tbreak;\n+\tcase MAIR_EL1:\t\twrite_sysreg_s(val, SYS_MAIR_EL12);\tbreak;\n+\tcase VBAR_EL1:\t\twrite_sysreg_s(val, SYS_VBAR_EL12);\tbreak;\n+\tcase CONTEXTIDR_EL1:\twrite_sysreg_s(val, SYS_CONTEXTIDR_EL12);break;\n+\tcase AMAIR_EL1:\t\twrite_sysreg_s(val, SYS_AMAIR_EL12);\tbreak;\n+\tcase CNTKCTL_EL1:\twrite_sysreg_s(val, SYS_CNTKCTL_EL12);\tbreak;\n+\tcase ELR_EL1:\t\twrite_sysreg_s(val, SYS_ELR_EL12);\tbreak;\n+\tcase SPSR_EL1:\t\twrite_sysreg_s(val, SYS_SPSR_EL12);\tbreak;\n+\tcase ZCR_EL1:\t\twrite_sysreg_s(val, SYS_ZCR_EL12);\tbreak;\n+\tcase SCTLR2_EL1:\twrite_sysreg_s(val, SYS_SCTLR2_EL12);\tbreak;\n+\tcase TPIDR_EL0:\t\twrite_sysreg_s(val, SYS_TPIDR_EL0);\tbreak;\n+\tcase TPIDRRO_EL0:\twrite_sysreg_s(val, SYS_TPIDRRO_EL0);\tbreak;\n+\tcase TPIDR_EL1:\t\twrite_sysreg_s(val, SYS_TPIDR_EL1);\tbreak;\n+\tcase PAR_EL1:\t\twrite_sysreg_s(val, SYS_PAR_EL1);\tbreak;\n+\tcase DACR32_EL2:\twrite_sysreg_s(val, SYS_DACR32_EL2);\tbreak;\n+\tcase IFSR32_EL2:\twrite_sysreg_s(val, SYS_IFSR32_EL2);\tbreak;\n+\tcase DBGVCR32_EL2:\twrite_sysreg_s(val, SYS_DBGVCR32_EL2);\tbreak;\n+\tdefault:\t\tWARN_ON_ONCE(1);\n+\t}\n+}\n+\n+u64 vcpu_read_sys_reg(const struct kvm_vcpu *vcpu, enum vcpu_sysreg reg)\n+{\n+\tstruct sr_loc loc = {};\n+\n+\tlocate_register(vcpu, reg, &loc);\n+\n+\tWARN_ON_ONCE(!has_vhe() && loc.loc != SR_LOC_MEMORY);\n+\n+\tif (loc.loc & SR_LOC_SPECIAL) {\n+\t\tu64 val;\n+\n+\t\tWARN_ON_ONCE(loc.loc & ~SR_LOC_SPECIAL);\n \n \t\t/*\n-\t\t * CNTHCTL_EL2 requires some special treatment to\n-\t\t * account for the bits that can be set via CNTKCTL_EL1.\n+\t\t * CNTHCTL_EL2 requires some special treatment to account\n+\t\t * for the bits that can be set via CNTKCTL_EL1 when E2H==1.\n \t\t */\n \t\tswitch (reg) {\n \t\tcase CNTHCTL_EL2:\n-\t\t\tif (vcpu_el2_e2h_is_set(vcpu)) {\n-\t\t\t\tval = read_sysreg_el1(SYS_CNTKCTL);\n-\t\t\t\tval &= CNTKCTL_VALID_BITS;\n-\t\t\t\tval |= __vcpu_sys_reg(vcpu, reg) & ~CNTKCTL_VALID_BITS;\n-\t\t\t\treturn val;\n-\t\t\t}\n-\t\t\tbreak;\n+\t\t\tval = read_sysreg_el1(SYS_CNTKCTL);\n+\t\t\tval &= CNTKCTL_VALID_BITS;\n+\t\t\tval |= __vcpu_sys_reg(vcpu, reg) & ~CNTKCTL_VALID_BITS;\n+\t\t\treturn val;\n+\t\tdefault:\n+\t\t\tWARN_ON_ONCE(1);\n \t\t}\n+\t}\n \n-\t\t/*\n-\t\t * If this register does not have an EL1 counterpart,\n-\t\t * then read the stored EL2 version.\n-\t\t */\n-\t\tif (reg == el1r)\n-\t\t\tgoto memory_read;\n+\tif (loc.loc & SR_LOC_LOADED) {\n+\t\tenum vcpu_sysreg map_reg = reg;\n \n-\t\t/*\n-\t\t * If we have a non-VHE guest and that the sysreg\n-\t\t * requires translation to be used at EL1, use the\n-\t\t * in-memory copy instead.\n-\t\t */\n-\t\tif (!vcpu_el2_e2h_is_set(vcpu) && xlate)\n-\t\t\tgoto memory_read;\n+\t\tif (loc.loc & SR_LOC_MAPPED)\n+\t\t\tmap_reg = loc.map_reg;\n \n-\t\t/* Get the current version of the EL1 counterpart. */\n-\t\tWARN_ON(!__vcpu_read_sys_reg_from_cpu(el1r, &val));\n-\t\tif (reg >= __SANITISED_REG_START__)\n-\t\t\tval = kvm_vcpu_apply_reg_masks(vcpu, reg, val);\n-\n-\t\treturn val;\n-\t}\n+\t\tif (!(loc.loc & SR_LOC_XLATED)) {\n+\t\t\tu64 val = read_sr_from_cpu(map_reg);\n \n-\t/* EL1 register can't be on the CPU if the guest is in vEL2. */\n-\tif (unlikely(is_hyp_ctxt(vcpu)))\n-\t\tgoto memory_read;\n+\t\t\tif (reg >= __SANITISED_REG_START__)\n+\t\t\t\tval = kvm_vcpu_apply_reg_masks(vcpu, reg, val);\n \n-\tif (__vcpu_read_sys_reg_from_cpu(reg, &val))\n-\t\treturn val;\n+\t\t\treturn val;\n+\t\t}\n+\t}\n \n-memory_read:\n \treturn __vcpu_sys_reg(vcpu, reg);\n }\n \n-void vcpu_write_sys_reg(struct kvm_vcpu *vcpu, u64 val, int reg)\n+void vcpu_write_sys_reg(struct kvm_vcpu *vcpu, u64 val, enum vcpu_sysreg reg)\n {\n-\tu64 (*xlate)(u64) = NULL;\n-\tunsigned int el1r;\n+\tstruct sr_loc loc = {};\n \n-\tif (!vcpu_get_flag(vcpu, SYSREGS_ON_CPU))\n-\t\tgoto memory_write;\n+\tlocate_register(vcpu, reg, &loc);\n \n-\tif (unlikely(get_el2_to_el1_mapping(reg, &el1r, &xlate))) {\n-\t\tif (!is_hyp_ctxt(vcpu))\n-\t\t\tgoto memory_write;\n+\tWARN_ON_ONCE(!has_vhe() && loc.loc != SR_LOC_MEMORY);\n \n-\t\t/*\n-\t\t * Always store a copy of the write to memory to avoid having\n-\t\t * to reverse-translate virtual EL2 system registers for a\n-\t\t * non-VHE guest hypervisor.\n-\t\t */\n-\t\t__vcpu_assign_sys_reg(vcpu, reg, val);\n+\tif (loc.loc & SR_LOC_SPECIAL) {\n+\n+\t\tWARN_ON_ONCE(loc.loc & ~SR_LOC_SPECIAL);\n \n \t\tswitch (reg) {\n \t\tcase CNTHCTL_EL2:\n \t\t\t/*\n-\t\t\t * If E2H=0, CNHTCTL_EL2 is a pure shadow register.\n-\t\t\t * Otherwise, some of the bits are backed by\n+\t\t\t * If E2H=1, some of the bits are backed by\n \t\t\t * CNTKCTL_EL1, while the rest is kept in memory.\n \t\t\t * Yes, this is fun stuff.\n \t\t\t */\n-\t\t\tif (vcpu_el2_e2h_is_set(vcpu))\n-\t\t\t\twrite_sysreg_el1(val, SYS_CNTKCTL);\n-\t\t\treturn;\n+\t\t\twrite_sysreg_el1(val, SYS_CNTKCTL);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tWARN_ON_ONCE(1);\n \t\t}\n+\t}\n \n-\t\t/* No EL1 counterpart? We're done here.? */\n-\t\tif (reg == el1r)\n-\t\t\treturn;\n+\tif (loc.loc & SR_LOC_LOADED) {\n+\t\tenum vcpu_sysreg map_reg = reg;\n+\t\tu64 xlated_val;\n \n-\t\tif (!vcpu_el2_e2h_is_set(vcpu) && xlate)\n-\t\t\tval = xlate(val);\n+\t\tif (reg >= __SANITISED_REG_START__)\n+\t\t\tval = kvm_vcpu_apply_reg_masks(vcpu, reg, val);\n \n-\t\t/* Redirect this to the EL1 version of the register. */\n-\t\tWARN_ON(!__vcpu_write_sys_reg_to_cpu(val, el1r));\n-\t\treturn;\n-\t}\n+\t\tif (loc.loc & SR_LOC_MAPPED)\n+\t\t\tmap_reg = loc.map_reg;\n \n-\t/* EL1 register can't be on the CPU if the guest is in vEL2. */\n-\tif (unlikely(is_hyp_ctxt(vcpu)))\n-\t\tgoto memory_write;\n+\t\tif (loc.loc & SR_LOC_XLATED)\n+\t\t\txlated_val = loc.xlate(val);\n+\t\telse\n+\t\t\txlated_val = val;\n \n-\tif (__vcpu_write_sys_reg_to_cpu(val, reg))\n-\t\treturn;\n+\t\twrite_sr_to_cpu(map_reg, xlated_val);\n+\n+\t\t/*\n+\t\t * Fall through to write the backing store anyway, which\n+\t\t * allows translated registers to be directly read without a\n+\t\t * reverse translation.\n+\t\t */\n+\t}\n \n-memory_write:\n \t__vcpu_assign_sys_reg(vcpu, reg, val);\n }\n \n@@ -1584,6 +1710,7 @@ static u8 pmuver_to_perfmon(u8 pmuver)\n }\n \n static u64 sanitise_id_aa64pfr0_el1(const struct kvm_vcpu *vcpu, u64 val);\n+static u64 sanitise_id_aa64pfr1_el1(const struct kvm_vcpu *vcpu, u64 val);\n static u64 sanitise_id_aa64dfr0_el1(const struct kvm_vcpu *vcpu, u64 val);\n \n /* Read a sanitised cpufeature ID register by sys_reg_desc */\n@@ -1606,19 +1733,7 @@ static u64 __kvm_read_sanitised_id_reg(const struct kvm_vcpu *vcpu,\n \t\tval = sanitise_id_aa64pfr0_el1(vcpu, val);\n \t\tbreak;\n \tcase SYS_ID_AA64PFR1_EL1:\n-\t\tif (!kvm_has_mte(vcpu->kvm)) {\n-\t\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTE);\n-\t\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTE_frac);\n-\t\t}\n-\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_SME);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_RNDR_trap);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_NMI);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_GCS);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_THE);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTEX);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_PFAR);\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MPAM_frac);\n+\t\tval = sanitise_id_aa64pfr1_el1(vcpu, val);\n \t\tbreak;\n \tcase SYS_ID_AA64PFR2_EL1:\n \t\tval &= ID_AA64PFR2_EL1_FPMR |\n@@ -1628,18 +1743,18 @@ static u64 __kvm_read_sanitised_id_reg(const struct kvm_vcpu *vcpu,\n \t\tbreak;\n \tcase SYS_ID_AA64ISAR1_EL1:\n \t\tif (!vcpu_has_ptrauth(vcpu))\n-\t\t\tval &= ~(ARM64_FEATURE_MASK(ID_AA64ISAR1_EL1_APA) |\n-\t\t\t\t ARM64_FEATURE_MASK(ID_AA64ISAR1_EL1_API) |\n-\t\t\t\t ARM64_FEATURE_MASK(ID_AA64ISAR1_EL1_GPA) |\n-\t\t\t\t ARM64_FEATURE_MASK(ID_AA64ISAR1_EL1_GPI));\n+\t\t\tval &= ~(ID_AA64ISAR1_EL1_APA |\n+\t\t\t\t ID_AA64ISAR1_EL1_API |\n+\t\t\t\t ID_AA64ISAR1_EL1_GPA |\n+\t\t\t\t ID_AA64ISAR1_EL1_GPI);\n \t\tbreak;\n \tcase SYS_ID_AA64ISAR2_EL1:\n \t\tif (!vcpu_has_ptrauth(vcpu))\n-\t\t\tval &= ~(ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_APA3) |\n-\t\t\t\t ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_GPA3));\n+\t\t\tval &= ~(ID_AA64ISAR2_EL1_APA3 |\n+\t\t\t\t ID_AA64ISAR2_EL1_GPA3);\n \t\tif (!cpus_have_final_cap(ARM64_HAS_WFXT) ||\n \t\t    has_broken_cntvoff())\n-\t\t\tval &= ~ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_WFxT);\n+\t\t\tval &= ~ID_AA64ISAR2_EL1_WFxT;\n \t\tbreak;\n \tcase SYS_ID_AA64ISAR3_EL1:\n \t\tval &= ID_AA64ISAR3_EL1_FPRCVT | ID_AA64ISAR3_EL1_FAMINMAX;\n@@ -1655,7 +1770,7 @@ static u64 __kvm_read_sanitised_id_reg(const struct kvm_vcpu *vcpu,\n \t\t       ID_AA64MMFR3_EL1_S1PIE;\n \t\tbreak;\n \tcase SYS_ID_MMFR4_EL1:\n-\t\tval &= ~ARM64_FEATURE_MASK(ID_MMFR4_EL1_CCIDX);\n+\t\tval &= ~ID_MMFR4_EL1_CCIDX;\n \t\tbreak;\n \t}\n \n@@ -1836,6 +1951,31 @@ static u64 sanitise_id_aa64pfr0_el1(const struct kvm_vcpu *vcpu, u64 val)\n \treturn val;\n }\n \n+static u64 sanitise_id_aa64pfr1_el1(const struct kvm_vcpu *vcpu, u64 val)\n+{\n+\tu64 pfr0 = read_sanitised_ftr_reg(SYS_ID_AA64PFR0_EL1);\n+\n+\tif (!kvm_has_mte(vcpu->kvm)) {\n+\t\tval &= ~ID_AA64PFR1_EL1_MTE;\n+\t\tval &= ~ID_AA64PFR1_EL1_MTE_frac;\n+\t}\n+\n+\tif (!(cpus_have_final_cap(ARM64_HAS_RASV1P1_EXTN) &&\n+\t      SYS_FIELD_GET(ID_AA64PFR0_EL1, RAS, pfr0) == ID_AA64PFR0_EL1_RAS_IMP))\n+\t\tval &= ~ID_AA64PFR1_EL1_RAS_frac;\n+\n+\tval &= ~ID_AA64PFR1_EL1_SME;\n+\tval &= ~ID_AA64PFR1_EL1_RNDR_trap;\n+\tval &= ~ID_AA64PFR1_EL1_NMI;\n+\tval &= ~ID_AA64PFR1_EL1_GCS;\n+\tval &= ~ID_AA64PFR1_EL1_THE;\n+\tval &= ~ID_AA64PFR1_EL1_MTEX;\n+\tval &= ~ID_AA64PFR1_EL1_PFAR;\n+\tval &= ~ID_AA64PFR1_EL1_MPAM_frac;\n+\n+\treturn val;\n+}\n+\n static u64 sanitise_id_aa64dfr0_el1(const struct kvm_vcpu *vcpu, u64 val)\n {\n \tval = ID_REG_LIMIT_FIELD_ENUM(val, ID_AA64DFR0_EL1, DebugVer, V8P8);\n@@ -2697,6 +2837,18 @@ static bool access_ras(struct kvm_vcpu *vcpu,\n \tstruct kvm *kvm = vcpu->kvm;\n \n \tswitch(reg_to_encoding(r)) {\n+\tcase SYS_ERXPFGCDN_EL1:\n+\tcase SYS_ERXPFGCTL_EL1:\n+\tcase SYS_ERXPFGF_EL1:\n+\tcase SYS_ERXMISC2_EL1:\n+\tcase SYS_ERXMISC3_EL1:\n+\t\tif (!(kvm_has_feat(kvm, ID_AA64PFR0_EL1, RAS, V1P1) ||\n+\t\t      (kvm_has_feat_enum(kvm, ID_AA64PFR0_EL1, RAS, IMP) &&\n+\t\t       kvm_has_feat(kvm, ID_AA64PFR1_EL1, RAS_frac, RASv1p1)))) {\n+\t\t\tkvm_inject_undefined(vcpu);\n+\t\t\treturn false;\n+\t\t}\n+\t\tbreak;\n \tdefault:\n \t\tif (!kvm_has_feat(kvm, ID_AA64PFR0_EL1, RAS, IMP)) {\n \t\t\tkvm_inject_undefined(vcpu);\n@@ -2929,7 +3081,6 @@ static const struct sys_reg_desc sys_reg_descs[] = {\n \t\t    ~(ID_AA64PFR0_EL1_AMU |\n \t\t      ID_AA64PFR0_EL1_MPAM |\n \t\t      ID_AA64PFR0_EL1_SVE |\n-\t\t      ID_AA64PFR0_EL1_RAS |\n \t\t      ID_AA64PFR0_EL1_AdvSIMD |\n \t\t      ID_AA64PFR0_EL1_FP)),\n \tID_FILTERED(ID_AA64PFR1_EL1, id_aa64pfr1_el1,\n@@ -2943,7 +3094,6 @@ static const struct sys_reg_desc sys_reg_descs[] = {\n \t\t\t\t       ID_AA64PFR1_EL1_SME |\n \t\t\t\t       ID_AA64PFR1_EL1_RES0 |\n \t\t\t\t       ID_AA64PFR1_EL1_MPAM_frac |\n-\t\t\t\t       ID_AA64PFR1_EL1_RAS_frac |\n \t\t\t\t       ID_AA64PFR1_EL1_MTE)),\n \tID_WRITABLE(ID_AA64PFR2_EL1,\n \t\t    ID_AA64PFR2_EL1_FPMR |\n@@ -3063,8 +3213,13 @@ static const struct sys_reg_desc sys_reg_descs[] = {\n \t{ SYS_DESC(SYS_ERXCTLR_EL1), access_ras },\n \t{ SYS_DESC(SYS_ERXSTATUS_EL1), access_ras },\n \t{ SYS_DESC(SYS_ERXADDR_EL1), access_ras },\n+\t{ SYS_DESC(SYS_ERXPFGF_EL1), access_ras },\n+\t{ SYS_DESC(SYS_ERXPFGCTL_EL1), access_ras },\n+\t{ SYS_DESC(SYS_ERXPFGCDN_EL1), access_ras },\n \t{ SYS_DESC(SYS_ERXMISC0_EL1), access_ras },\n \t{ SYS_DESC(SYS_ERXMISC1_EL1), access_ras },\n+\t{ SYS_DESC(SYS_ERXMISC2_EL1), access_ras },\n+\t{ SYS_DESC(SYS_ERXMISC3_EL1), access_ras },\n \n \tMTE_REG(TFSR_EL1),\n \tMTE_REG(TFSRE0_EL1),"
        },
        {
            "sha": "70d50c77e5dc7e6747fc99b256a5094ebf5db191",
            "filename": "arch/arm64/kvm/vgic/vgic-mmio-v3.c",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio-v3.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio-v3.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio-v3.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -50,6 +50,14 @@ bool vgic_has_its(struct kvm *kvm)\n \n bool vgic_supports_direct_msis(struct kvm *kvm)\n {\n+\t/*\n+\t * Deliberately conflate vLPI and vSGI support on GICv4.1 hardware,\n+\t * indirectly allowing userspace to control whether or not vPEs are\n+\t * allocated for the VM.\n+\t */\n+\tif (system_supports_direct_sgis() && !vgic_supports_direct_sgis(kvm))\n+\t\treturn false;\n+\n \treturn kvm_vgic_global_state.has_gicv4 && vgic_has_its(kvm);\n }\n "
        },
        {
            "sha": "a573b1f0c6cbeee347aa50426d37ddb018d741c2",
            "filename": "arch/arm64/kvm/vgic/vgic-mmio.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic-mmio.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1091,7 +1091,7 @@ int vgic_register_dist_iodev(struct kvm *kvm, gpa_t dist_base_address,\n \t\tlen = vgic_v3_init_dist_iodev(io_device);\n \t\tbreak;\n \tdefault:\n-\t\tBUG_ON(1);\n+\t\tBUG();\n \t}\n \n \tio_device->base_addr = dist_base_address;"
        },
        {
            "sha": "de1c1d3261c3966707aae8e379b09e478ae6070e",
            "filename": "arch/arm64/kvm/vgic/vgic.h",
            "status": "modified",
            "additions": 1,
            "deletions": 9,
            "changes": 10,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Fkvm%2Fvgic%2Fvgic.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -396,15 +396,7 @@ bool vgic_supports_direct_sgis(struct kvm *kvm);\n \n static inline bool vgic_supports_direct_irqs(struct kvm *kvm)\n {\n-\t/*\n-\t * Deliberately conflate vLPI and vSGI support on GICv4.1 hardware,\n-\t * indirectly allowing userspace to control whether or not vPEs are\n-\t * allocated for the VM.\n-\t */\n-\tif (system_supports_direct_sgis())\n-\t\treturn vgic_supports_direct_sgis(kvm);\n-\n-\treturn vgic_supports_direct_msis(kvm);\n+\treturn vgic_supports_direct_msis(kvm) || vgic_supports_direct_sgis(kvm);\n }\n \n int vgic_v4_init(struct kvm *kvm);"
        },
        {
            "sha": "9ff5cdbd27597b3b18b10d43246e303577ee7bae",
            "filename": "arch/arm64/tools/cpucaps",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Ftools%2Fcpucaps",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Farm64%2Ftools%2Fcpucaps",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Farm64%2Ftools%2Fcpucaps?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -53,6 +53,7 @@ HAS_S1PIE\n HAS_S1POE\n HAS_SCTLR2\n HAS_RAS_EXTN\n+HAS_RASV1P1_EXTN\n HAS_RNG\n HAS_SB\n HAS_STAGE2_FWB"
        },
        {
            "sha": "525fb5a330c0d20b71ee8e27092efe05dc4cd88f",
            "filename": "arch/riscv/kvm/mmu.c",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fmmu.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fmmu.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Friscv%2Fkvm%2Fmmu.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -39,6 +39,7 @@ int kvm_riscv_mmu_ioremap(struct kvm *kvm, gpa_t gpa, phys_addr_t hpa,\n \t\t\t  unsigned long size, bool writable, bool in_atomic)\n {\n \tint ret = 0;\n+\tpgprot_t prot;\n \tunsigned long pfn;\n \tphys_addr_t addr, end;\n \tstruct kvm_mmu_memory_cache pcache = {\n@@ -55,10 +56,12 @@ int kvm_riscv_mmu_ioremap(struct kvm *kvm, gpa_t gpa, phys_addr_t hpa,\n \n \tend = (gpa + size + PAGE_SIZE - 1) & PAGE_MASK;\n \tpfn = __phys_to_pfn(hpa);\n+\tprot = pgprot_noncached(PAGE_WRITE);\n \n \tfor (addr = gpa; addr < end; addr += PAGE_SIZE) {\n \t\tmap.addr = addr;\n-\t\tmap.pte = pfn_pte(pfn, PAGE_KERNEL_IO);\n+\t\tmap.pte = pfn_pte(pfn, prot);\n+\t\tmap.pte = pte_mkdirty(map.pte);\n \t\tmap.level = 0;\n \n \t\tif (!writable)"
        },
        {
            "sha": "3ebcfffaa978154157cafe976b532ad36e79f3a7",
            "filename": "arch/riscv/kvm/vcpu.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fvcpu.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fvcpu.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Friscv%2Fkvm%2Fvcpu.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -683,7 +683,7 @@ void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n }\n \n /**\n- * check_vcpu_requests - check and handle pending vCPU requests\n+ * kvm_riscv_check_vcpu_requests - check and handle pending vCPU requests\n  * @vcpu:\tthe VCPU pointer\n  *\n  * Return: 1 if we should enter the guest"
        },
        {
            "sha": "05f3cc2d8e311ac62a56186b3599b5d389bf6f83",
            "filename": "arch/riscv/kvm/vcpu_vector.c",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fvcpu_vector.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Friscv%2Fkvm%2Fvcpu_vector.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Friscv%2Fkvm%2Fvcpu_vector.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -182,6 +182,8 @@ int kvm_riscv_vcpu_set_reg_vector(struct kvm_vcpu *vcpu,\n \t\tstruct kvm_cpu_context *cntx = &vcpu->arch.guest_context;\n \t\tunsigned long reg_val;\n \n+\t\tif (reg_size != sizeof(reg_val))\n+\t\t\treturn -EINVAL;\n \t\tif (copy_from_user(&reg_val, uaddr, reg_size))\n \t\t\treturn -EFAULT;\n \t\tif (reg_val != cntx->vector.vlenb)"
        },
        {
            "sha": "5fc437341e03a90d5523e25ceda7900accb4a611",
            "filename": "arch/x86/kvm/lapic.c",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Flapic.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Flapic.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Fx86%2Fkvm%2Flapic.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -810,6 +810,8 @@ static int __pv_send_ipi(unsigned long *ipi_bitmap, struct kvm_apic_map *map,\n \tif (min > map->max_apic_id)\n \t\treturn 0;\n \n+\tmin = array_index_nospec(min, map->max_apic_id + 1);\n+\n \tfor_each_set_bit(i, ipi_bitmap,\n \t\tmin((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))) {\n \t\tif (map->phys_map[min + i]) {"
        },
        {
            "sha": "0635bd71c10e78331e392f1db4fca4a77551f1c5",
            "filename": "arch/x86/kvm/svm/sev.c",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Fsvm%2Fsev.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Fsvm%2Fsev.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Fx86%2Fkvm%2Fsvm%2Fsev.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -718,13 +718,6 @@ static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n \n static void sev_writeback_caches(struct kvm *kvm)\n {\n-\t/*\n-\t * Note, the caller is responsible for ensuring correctness if the mask\n-\t * can be modified, e.g. if a CPU could be doing VMRUN.\n-\t */\n-\tif (cpumask_empty(to_kvm_sev_info(kvm)->have_run_cpus))\n-\t\treturn;\n-\n \t/*\n \t * Ensure that all dirty guest tagged cache entries are written back\n \t * before releasing the pages back to the system for use.  CLFLUSH will\n@@ -739,6 +732,9 @@ static void sev_writeback_caches(struct kvm *kvm)\n \t * serializing multiple calls and having responding CPUs (to the IPI)\n \t * mark themselves as still running if they are running (or about to\n \t * run) a vCPU for the VM.\n+\t *\n+\t * Note, the caller is responsible for ensuring correctness if the mask\n+\t * can be modified, e.g. if a CPU could be doing VMRUN.\n \t */\n \twbnoinvd_on_cpus_mask(to_kvm_sev_info(kvm)->have_run_cpus);\n }"
        },
        {
            "sha": "604490b1cb19c7492f0a4241a0a0011c24fcc6bc",
            "filename": "arch/x86/kvm/x86.c",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Fx86.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/arch%2Fx86%2Fkvm%2Fx86.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/arch%2Fx86%2Fkvm%2Fx86.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -9908,8 +9908,11 @@ static void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)\n \trcu_read_lock();\n \tmap = rcu_dereference(vcpu->kvm->arch.apic_map);\n \n-\tif (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])\n-\t\ttarget = map->phys_map[dest_id]->vcpu;\n+\tif (likely(map) && dest_id <= map->max_apic_id) {\n+\t\tdest_id = array_index_nospec(dest_id, map->max_apic_id + 1);\n+\t\tif (map->phys_map[dest_id])\n+\t\t\ttarget = map->phys_map[dest_id]->vcpu;\n+\t}\n \n \trcu_read_unlock();\n "
        },
        {
            "sha": "65f2759ea27a35cfce57f7459d8f16f1c002f0af",
            "filename": "tools/arch/arm64/include/asm/sysreg.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Farch%2Farm64%2Finclude%2Fasm%2Fsysreg.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Farch%2Farm64%2Finclude%2Fasm%2Fsysreg.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Farch%2Farm64%2Finclude%2Fasm%2Fsysreg.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -1080,9 +1080,6 @@\n \n #define ARM64_FEATURE_FIELD_BITS\t4\n \n-/* Defined for compatibility only, do not add new users. */\n-#define ARM64_FEATURE_MASK(x)\t(x##_MASK)\n-\n #ifdef __ASSEMBLY__\n \n \t.macro\tmrs_s, rt, sreg"
        },
        {
            "sha": "8516e8434bc45cbfce163359082f9cf6b01f7e25",
            "filename": "tools/testing/selftests/kselftest_harness.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkselftest_harness.h",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkselftest_harness.h",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkselftest_harness.h?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -751,15 +751,15 @@\n \tfor (; _metadata->trigger; _metadata->trigger = \\\n \t\t\t__bail(_assert, _metadata))\n \n-#define is_signed_type(var)       (!!(((__typeof__(var))(-1)) < (__typeof__(var))1))\n+#define is_signed_var(var)\t(!!(((__typeof__(var))(-1)) < (__typeof__(var))1))\n \n #define __EXPECT(_expected, _expected_str, _seen, _seen_str, _t, _assert) do { \\\n \t/* Avoid multiple evaluation of the cases */ \\\n \t__typeof__(_expected) __exp = (_expected); \\\n \t__typeof__(_seen) __seen = (_seen); \\\n \tif (!(__exp _t __seen)) { \\\n \t\t/* Report with actual signedness to avoid weird output. */ \\\n-\t\tswitch (is_signed_type(__exp) * 2 + is_signed_type(__seen)) { \\\n+\t\tswitch (is_signed_var(__exp) * 2 + is_signed_var(__seen)) { \\\n \t\tcase 0: { \\\n \t\t\tuintmax_t __exp_print = (uintmax_t)__exp; \\\n \t\t\tuintmax_t __seen_print = (uintmax_t)__seen; \\"
        },
        {
            "sha": "41b40c676d7f38a7726851510d0c38c97d36d79e",
            "filename": "tools/testing/selftests/kvm/Makefile.kvm",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2FMakefile.kvm",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2FMakefile.kvm",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2FMakefile.kvm?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -169,6 +169,7 @@ TEST_GEN_PROGS_arm64 += arm64/vgic_irq\n TEST_GEN_PROGS_arm64 += arm64/vgic_lpi_stress\n TEST_GEN_PROGS_arm64 += arm64/vpmu_counter_access\n TEST_GEN_PROGS_arm64 += arm64/no-vgic-v3\n+TEST_GEN_PROGS_arm64 += arm64/kvm-uuid\n TEST_GEN_PROGS_arm64 += access_tracking_perf_test\n TEST_GEN_PROGS_arm64 += arch_timer\n TEST_GEN_PROGS_arm64 += coalesced_io_test"
        },
        {
            "sha": "713005b6f508e800c1c62b0e8ed8c4f2dab9de71",
            "filename": "tools/testing/selftests/kvm/arm64/aarch32_id_regs.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Faarch32_id_regs.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Faarch32_id_regs.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Faarch32_id_regs.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -146,7 +146,7 @@ static bool vcpu_aarch64_only(struct kvm_vcpu *vcpu)\n \n \tval = vcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR0_EL1));\n \n-\tel0 = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_EL0), val);\n+\tel0 = FIELD_GET(ID_AA64PFR0_EL1_EL0, val);\n \treturn el0 == ID_AA64PFR0_EL1_EL0_IMP;\n }\n "
        },
        {
            "sha": "1d431de8729c58bafdf572fd14238e36917bfe40",
            "filename": "tools/testing/selftests/kvm/arm64/debug-exceptions.c",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fdebug-exceptions.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fdebug-exceptions.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fdebug-exceptions.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -116,12 +116,12 @@ static void reset_debug_state(void)\n \n \t/* Reset all bcr/bvr/wcr/wvr registers */\n \tdfr0 = read_sysreg(id_aa64dfr0_el1);\n-\tbrps = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_BRPs), dfr0);\n+\tbrps = FIELD_GET(ID_AA64DFR0_EL1_BRPs, dfr0);\n \tfor (i = 0; i <= brps; i++) {\n \t\twrite_dbgbcr(i, 0);\n \t\twrite_dbgbvr(i, 0);\n \t}\n-\twrps = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_WRPs), dfr0);\n+\twrps = FIELD_GET(ID_AA64DFR0_EL1_WRPs, dfr0);\n \tfor (i = 0; i <= wrps; i++) {\n \t\twrite_dbgwcr(i, 0);\n \t\twrite_dbgwvr(i, 0);\n@@ -418,7 +418,7 @@ static void guest_code_ss(int test_cnt)\n \n static int debug_version(uint64_t id_aa64dfr0)\n {\n-\treturn FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_DebugVer), id_aa64dfr0);\n+\treturn FIELD_GET(ID_AA64DFR0_EL1_DebugVer, id_aa64dfr0);\n }\n \n static void test_guest_debug_exceptions(uint8_t bpn, uint8_t wpn, uint8_t ctx_bpn)\n@@ -539,14 +539,14 @@ void test_guest_debug_exceptions_all(uint64_t aa64dfr0)\n \tint b, w, c;\n \n \t/* Number of breakpoints */\n-\tbrp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_BRPs), aa64dfr0) + 1;\n+\tbrp_num = FIELD_GET(ID_AA64DFR0_EL1_BRPs, aa64dfr0) + 1;\n \t__TEST_REQUIRE(brp_num >= 2, \"At least two breakpoints are required\");\n \n \t/* Number of watchpoints */\n-\twrp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_WRPs), aa64dfr0) + 1;\n+\twrp_num = FIELD_GET(ID_AA64DFR0_EL1_WRPs, aa64dfr0) + 1;\n \n \t/* Number of context aware breakpoints */\n-\tctx_brp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_CTX_CMPs), aa64dfr0) + 1;\n+\tctx_brp_num = FIELD_GET(ID_AA64DFR0_EL1_CTX_CMPs, aa64dfr0) + 1;\n \n \tpr_debug(\"%s brp_num:%d, wrp_num:%d, ctx_brp_num:%d\\n\", __func__,\n \t\t brp_num, wrp_num, ctx_brp_num);"
        },
        {
            "sha": "af9581b860f143b1e08d8263fa98799d09cd3d1c",
            "filename": "tools/testing/selftests/kvm/arm64/kvm-uuid.c",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fkvm-uuid.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fkvm-uuid.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fkvm-uuid.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -0,0 +1,70 @@\n+// SPDX-License-Identifier: GPL-2.0\n+\n+// Check that nobody has tampered with KVM's UID\n+\n+#include <errno.h>\n+#include <linux/arm-smccc.h>\n+#include <asm/kvm.h>\n+#include <kvm_util.h>\n+\n+#include \"processor.h\"\n+\n+/*\n+ * Do NOT redefine these constants, or try to replace them with some\n+ * \"common\" version. They are hardcoded here to detect any potential\n+ * breakage happening in the rest of the kernel.\n+ *\n+ * KVM UID value: 28b46fb6-2ec5-11e9-a9ca-4b564d003a74\n+ */\n+#define ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_0\t0xb66fb428U\n+#define ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_1\t0xe911c52eU\n+#define ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_2\t0x564bcaa9U\n+#define ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_3\t0x743a004dU\n+\n+static void guest_code(void)\n+{\n+\tstruct arm_smccc_res res = {};\n+\n+\tsmccc_hvc(ARM_SMCCC_VENDOR_HYP_CALL_UID_FUNC_ID, 0, 0, 0, 0, 0, 0, 0, &res);\n+\n+\t__GUEST_ASSERT(res.a0 == ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_0 &&\n+\t\t       res.a1 == ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_1 &&\n+\t\t       res.a2 == ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_2 &&\n+\t\t       res.a3 == ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_3,\n+\t\t       \"Unexpected KVM-specific UID %lx %lx %lx %lx\\n\", res.a0, res.a1, res.a2, res.a3);\n+\tGUEST_DONE();\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+\tstruct kvm_vcpu *vcpu;\n+\tstruct kvm_vm *vm;\n+\tstruct ucall uc;\n+\tbool guest_done = false;\n+\n+\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n+\n+\twhile (!guest_done) {\n+\t\tvcpu_run(vcpu);\n+\n+\t\tswitch (get_ucall(vcpu, &uc)) {\n+\t\tcase UCALL_SYNC:\n+\t\t\tbreak;\n+\t\tcase UCALL_DONE:\n+\t\t\tguest_done = true;\n+\t\t\tbreak;\n+\t\tcase UCALL_ABORT:\n+\t\t\tREPORT_GUEST_ASSERT(uc);\n+\t\t\tbreak;\n+\t\tcase UCALL_PRINTF:\n+\t\t\tprintf(\"%s\", uc.buffer);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tTEST_FAIL(\"Unexpected guest exit\");\n+\t\t}\n+\t}\n+\n+\tkvm_vm_free(vm);\n+\n+\treturn 0;\n+}"
        },
        {
            "sha": "f222538e608418065d745c6df07378269486550b",
            "filename": "tools/testing/selftests/kvm/arm64/no-vgic-v3.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fno-vgic-v3.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fno-vgic-v3.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fno-vgic-v3.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -54,7 +54,7 @@ static void guest_code(void)\n \t * Check that we advertise that ID_AA64PFR0_EL1.GIC == 0, having\n \t * hidden the feature at runtime without any other userspace action.\n \t */\n-\t__GUEST_ASSERT(FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_GIC),\n+\t__GUEST_ASSERT(FIELD_GET(ID_AA64PFR0_EL1_GIC,\n \t\t\t\t read_sysreg(id_aa64pfr0_el1)) == 0,\n \t\t       \"GICv3 wrongly advertised\");\n \n@@ -165,7 +165,7 @@ int main(int argc, char *argv[])\n \n \tvm = vm_create_with_one_vcpu(&vcpu, NULL);\n \tpfr0 = vcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR0_EL1));\n-\t__TEST_REQUIRE(FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_GIC), pfr0),\n+\t__TEST_REQUIRE(FIELD_GET(ID_AA64PFR0_EL1_GIC, pfr0),\n \t\t       \"GICv3 not supported.\");\n \tkvm_vm_free(vm);\n "
        },
        {
            "sha": "4ccbd389d13369f687b66bb0c177385fbe4fdf5b",
            "filename": "tools/testing/selftests/kvm/arm64/page_fault_test.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fpage_fault_test.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fpage_fault_test.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fpage_fault_test.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -95,14 +95,14 @@ static bool guest_check_lse(void)\n \tuint64_t isar0 = read_sysreg(id_aa64isar0_el1);\n \tuint64_t atomic;\n \n-\tatomic = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64ISAR0_EL1_ATOMIC), isar0);\n+\tatomic = FIELD_GET(ID_AA64ISAR0_EL1_ATOMIC, isar0);\n \treturn atomic >= 2;\n }\n \n static bool guest_check_dc_zva(void)\n {\n \tuint64_t dczid = read_sysreg(dczid_el0);\n-\tuint64_t dzp = FIELD_GET(ARM64_FEATURE_MASK(DCZID_EL0_DZP), dczid);\n+\tuint64_t dzp = FIELD_GET(DCZID_EL0_DZP, dczid);\n \n \treturn dzp == 0;\n }\n@@ -195,7 +195,7 @@ static bool guest_set_ha(void)\n \tuint64_t hadbs, tcr;\n \n \t/* Skip if HA is not supported. */\n-\thadbs = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64MMFR1_EL1_HAFDBS), mmfr1);\n+\thadbs = FIELD_GET(ID_AA64MMFR1_EL1_HAFDBS, mmfr1);\n \tif (hadbs == 0)\n \t\treturn false;\n "
        },
        {
            "sha": "189321e969258c3151608214daf86882b1e51a74",
            "filename": "tools/testing/selftests/kvm/arm64/set_id_regs.c",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fset_id_regs.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fset_id_regs.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fset_id_regs.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -243,6 +243,7 @@ static void guest_code(void)\n \tGUEST_REG_SYNC(SYS_ID_AA64MMFR0_EL1);\n \tGUEST_REG_SYNC(SYS_ID_AA64MMFR1_EL1);\n \tGUEST_REG_SYNC(SYS_ID_AA64MMFR2_EL1);\n+\tGUEST_REG_SYNC(SYS_ID_AA64MMFR3_EL1);\n \tGUEST_REG_SYNC(SYS_ID_AA64ZFR0_EL1);\n \tGUEST_REG_SYNC(SYS_CTR_EL0);\n \tGUEST_REG_SYNC(SYS_MIDR_EL1);\n@@ -594,8 +595,8 @@ static void test_user_set_mte_reg(struct kvm_vcpu *vcpu)\n \t */\n \tval = vcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR1_EL1));\n \n-\tmte = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTE), val);\n-\tmte_frac = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTE_frac), val);\n+\tmte = FIELD_GET(ID_AA64PFR1_EL1_MTE, val);\n+\tmte_frac = FIELD_GET(ID_AA64PFR1_EL1_MTE_frac, val);\n \tif (mte != ID_AA64PFR1_EL1_MTE_MTE2 ||\n \t    mte_frac != ID_AA64PFR1_EL1_MTE_frac_NI) {\n \t\tksft_test_result_skip(\"MTE_ASYNC or MTE_ASYMM are supported, nothing to test\\n\");\n@@ -612,7 +613,7 @@ static void test_user_set_mte_reg(struct kvm_vcpu *vcpu)\n \t}\n \n \tval = vcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR1_EL1));\n-\tmte_frac = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR1_EL1_MTE_frac), val);\n+\tmte_frac = FIELD_GET(ID_AA64PFR1_EL1_MTE_frac, val);\n \tif (mte_frac == ID_AA64PFR1_EL1_MTE_frac_NI)\n \t\tksft_test_result_pass(\"ID_AA64PFR1_EL1.MTE_frac=0 accepted and still 0xF\\n\");\n \telse\n@@ -774,7 +775,7 @@ int main(void)\n \n \t/* Check for AARCH64 only system */\n \tval = vcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR0_EL1));\n-\tel0 = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR0_EL1_EL0), val);\n+\tel0 = FIELD_GET(ID_AA64PFR0_EL1_EL0, val);\n \taarch64_only = (el0 == ID_AA64PFR0_EL1_EL0_IMP);\n \n \tksft_print_header();"
        },
        {
            "sha": "a0c4ab8391559741a3e22e74869dcabd83c08393",
            "filename": "tools/testing/selftests/kvm/arm64/vpmu_counter_access.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fvpmu_counter_access.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fvpmu_counter_access.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Farm64%2Fvpmu_counter_access.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -441,7 +441,7 @@ static void create_vpmu_vm(void *guest_code)\n \n \t/* Make sure that PMUv3 support is indicated in the ID register */\n \tdfr0 = vcpu_get_reg(vpmu_vm.vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64DFR0_EL1));\n-\tpmuver = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_PMUVer), dfr0);\n+\tpmuver = FIELD_GET(ID_AA64DFR0_EL1_PMUVer, dfr0);\n \tTEST_ASSERT(pmuver != ID_AA64DFR0_EL1_PMUVer_IMP_DEF &&\n \t\t    pmuver >= ID_AA64DFR0_EL1_PMUVer_IMP,\n \t\t    \"Unexpected PMUVER (0x%x) on the vCPU with PMUv3\", pmuver);"
        },
        {
            "sha": "eb115123d74118035b6f09ecc52a4b51eca9be51",
            "filename": "tools/testing/selftests/kvm/lib/arm64/processor.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/torvalds/linux/blob/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Flib%2Farm64%2Fprocessor.c",
            "raw_url": "https://github.com/torvalds/linux/raw/11e7861d680c3757eab18ec0a474ff680e007dc4/tools%2Ftesting%2Fselftests%2Fkvm%2Flib%2Farm64%2Fprocessor.c",
            "contents_url": "https://api.github.com/repos/torvalds/linux/contents/tools%2Ftesting%2Fselftests%2Fkvm%2Flib%2Farm64%2Fprocessor.c?ref=11e7861d680c3757eab18ec0a474ff680e007dc4",
            "patch": "@@ -573,15 +573,15 @@ void aarch64_get_supported_page_sizes(uint32_t ipa, uint32_t *ipa4k,\n \terr = ioctl(vcpu_fd, KVM_GET_ONE_REG, &reg);\n \tTEST_ASSERT(err == 0, KVM_IOCTL_ERROR(KVM_GET_ONE_REG, vcpu_fd));\n \n-\tgran = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64MMFR0_EL1_TGRAN4), val);\n+\tgran = FIELD_GET(ID_AA64MMFR0_EL1_TGRAN4, val);\n \t*ipa4k = max_ipa_for_page_size(ipa, gran, ID_AA64MMFR0_EL1_TGRAN4_NI,\n \t\t\t\t\tID_AA64MMFR0_EL1_TGRAN4_52_BIT);\n \n-\tgran = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64MMFR0_EL1_TGRAN64), val);\n+\tgran = FIELD_GET(ID_AA64MMFR0_EL1_TGRAN64, val);\n \t*ipa64k = max_ipa_for_page_size(ipa, gran, ID_AA64MMFR0_EL1_TGRAN64_NI,\n \t\t\t\t\tID_AA64MMFR0_EL1_TGRAN64_IMP);\n \n-\tgran = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64MMFR0_EL1_TGRAN16), val);\n+\tgran = FIELD_GET(ID_AA64MMFR0_EL1_TGRAN16, val);\n \t*ipa16k = max_ipa_for_page_size(ipa, gran, ID_AA64MMFR0_EL1_TGRAN16_NI,\n \t\t\t\t\tID_AA64MMFR0_EL1_TGRAN16_52_BIT);\n "
        }
    ]
}
