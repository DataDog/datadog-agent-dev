# SPDX-FileCopyrightText: 2025-present Datadog, Inc. <dev@datadoghq.com>
#
# SPDX-License-Identifier: MIT
from __future__ import annotations

from typing import TYPE_CHECKING

import pytest

if TYPE_CHECKING:
    from collections.abc import Callable

    from dda.utils.fs import Path
    from tests.conftest import CliRunner


@pytest.fixture(name="create_temp_file_or_dir")
def fixt_create_temp_file_or_dir():
    """Fixture to create and clean up temporary files and directories."""
    created_paths: list[Path] = []

    def _create_temp_file_or_dir(location: Path, *, force_file: bool = False) -> None:
        for parent in reversed(location.parents):
            # Create and keep track of created parent directories for cleanup
            if not parent.exists():
                parent.mkdir()
                created_paths.append(parent)

        # Create the requested file or directory and keep track of it for cleanup
        # Assume that if the file path does not have an extension, it is a directory
        # The force_file flag can be used to override this behavior
        if location.suffix == "" and not force_file:
            location.mkdir()
        else:
            location.touch()
        created_paths.append(location)

    yield _create_temp_file_or_dir
    for path in reversed(created_paths):
        if path.exists():
            if path.is_dir():
                path.rmdir()
            else:
                path.unlink()


@pytest.fixture(name="create_cursor_rules")
def fixt_create_cursor_rules(create_temp_file_or_dir):
    def _create_cursor_rules(rules_data: dict[str, str], cursor_rules_dir: Path) -> None:
        """Create cursor rule files with given content."""
        for filename, content in rules_data.items():
            rule_file = cursor_rules_dir / filename
            create_temp_file_or_dir(rule_file, force_file=True)
            rule_file.write_text(content, encoding="utf-8")

    return _create_cursor_rules


def test_validate_basic_functionality(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test basic validation functionality with single rule file."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule for the project."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert "WARNING: This file is auto-generated by 'dda ai rules sync'" in content
    assert "Claude AI Assistant Rules" in content
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'test-rule.mdc'}" in content


def test_validate_multiple_rule_files(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test validation with multiple rule files."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {
        "coding-standards.mdc": "Use TypeScript for all frontend code.",
        "security.mdc": "Always validate input parameters.",
        "testing.mdc": "Write unit tests for all functions.",
    }

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    # Check that all rule files are referenced
    for filename in rules_data:
        assert f"@{cursor_rules_dir.relative_to(target_file.parent) / filename}" in content


def test_validate_without_fix_flag(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test validation without fix flag when files are out of sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules")

    assert result.exit_code == 1
    assert not target_file.exists()


def test_validate_with_fix_flag(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test validation with fix flag when files are out of sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'test-rule.mdc'}" in content


def test_validate_no_cursor_rules_directory(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test validation when cursor rules directory doesn't exist."""
    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules")

    assert result.exit_code == 0  # Should succeed when no rules directory
    # Should not create target file if no rules directory
    target_file = temp_dir / "CLAUDE.md"
    assert not target_file.exists()


def test_validate_empty_cursor_rules_directory(
    dda: CliRunner,
    temp_dir: Path,
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test validation when cursor rules directory exists but is empty."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    create_temp_file_or_dir(cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules")

    assert result.exit_code == 0
    # Should not create target file if no .mdc files
    target_file = temp_dir / "CLAUDE.md"
    assert not target_file.exists()


def test_validate_ignore_non_mdc_files(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test that validation ignores files that don't end with .mdc."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    # Create .mdc file and other files that should be ignored
    rules_data = {"valid-rule.mdc": "This is a valid rule."}
    create_cursor_rules(rules_data, cursor_rules_dir)

    # Create files that should be ignored
    ignored_file = cursor_rules_dir / "ignored.txt"
    create_temp_file_or_dir(ignored_file)
    ignored_file.write_text("This should be ignored", encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'valid-rule.mdc'}" in content
    assert "ignored.txt" not in content


def test_validate_in_sync(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test validation when files are already in sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        # First fix the files
        result = dda("validate", "ai-rules", "--fix")
        assert result.exit_code == 0

        # Then validate without fix
        result = dda("validate", "ai-rules")
        assert result.exit_code == 0


def test_validate_out_of_sync(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test validation when files are out of sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    # Create an outdated target file
    create_temp_file_or_dir(target_file)
    target_file.write_text("Old content", encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules")
        assert result.exit_code == 1


def test_validate_missing_target_file(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test validation when target file doesn't exist."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules")
        assert result.exit_code == 1


def test_validate_nested_directories(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test validation with nested rule directories."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    # Create nested structure
    nested_dir = cursor_rules_dir / "coding"
    nested_dir.mkdir(parents=True, exist_ok=True)

    rules_data = {"general.mdc": "General project rules.", "coding/typescript.mdc": "TypeScript specific rules."}

    # Create the rules manually for nested structure
    for filename, content in rules_data.items():
        rule_file = cursor_rules_dir / filename
        rule_file.parent.mkdir(parents=True, exist_ok=True)
        rule_file.write_text(content, encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'coding' / 'typescript.mdc'}" in content
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'general.mdc'}" in content


def test_validate_ignore_personal_rules(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test that personal rules are ignored."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"valid-rule.mdc": "This is a valid rule.", "rules/personal/my-rule.mdc": "This should be ignored."}

    # Create the rules manually for nested structure
    for filename, content in rules_data.items():
        rule_file = cursor_rules_dir / filename
        rule_file.parent.mkdir(parents=True, exist_ok=True)
        rule_file.write_text(content, encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("validate", "ai-rules", "--fix")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'valid-rule.mdc'}" in content
    assert "my-rule.mdc" not in content
