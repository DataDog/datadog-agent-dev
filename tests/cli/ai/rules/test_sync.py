# SPDX-FileCopyrightText: 2025-present Datadog, Inc. <dev@datadoghq.com>
#
# SPDX-License-Identifier: MIT
from __future__ import annotations

from typing import TYPE_CHECKING

import pytest

if TYPE_CHECKING:
    from collections.abc import Callable

    from dda.utils.fs import Path
    from tests.conftest import CliRunner


@pytest.fixture(name="create_temp_file_or_dir")
def fixt_create_temp_file_or_dir():
    """Fixture to create and clean up temporary files and directories."""
    created_paths: list[Path] = []

    def _create_temp_file_or_dir(location: Path, *, force_file: bool = False) -> None:
        for parent in reversed(location.parents):
            # Create and keep track of created parent directories for cleanup
            if not parent.exists():
                parent.mkdir()
                created_paths.append(parent)

        # Create the requested file or directory and keep track of it for cleanup
        # Assume that if the file path does not have an extension, it is a directory
        # The force_file flag can be used to override this behavior
        if location.suffix == "" and not force_file:
            location.mkdir()
        else:
            location.touch()
        created_paths.append(location)

    yield _create_temp_file_or_dir
    for path in reversed(created_paths):
        if path.exists():
            if path.is_dir():
                path.rmdir()
            else:
                path.unlink()


@pytest.fixture(name="create_cursor_rules")
def fixt_create_cursor_rules(create_temp_file_or_dir):
    def _create_cursor_rules(rules_data: dict[str, str], cursor_rules_dir: Path) -> None:
        """Create cursor rule files with given content."""
        for filename, content in rules_data.items():
            rule_file = cursor_rules_dir / filename
            create_temp_file_or_dir(rule_file, force_file=True)
            rule_file.write_text(content, encoding="utf-8")

    return _create_cursor_rules


def test_sync_basic_functionality(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test basic sync functionality with single rule file."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule for the project."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert "WARNING: This file is auto-generated by 'dda ai rules sync'" in content
    assert "Claude AI Assistant Rules" in content
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'test-rule.mdc'}" in content


def test_sync_multiple_rule_files(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test sync with multiple rule files."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {
        "coding-standards.mdc": "Use TypeScript for all frontend code.",
        "security.mdc": "Always validate input parameters.",
        "testing.mdc": "Write unit tests for all functions.",
    }

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    # Check that all rule files are referenced
    for filename in rules_data:
        assert f"@{cursor_rules_dir.relative_to(target_file.parent) / filename}" in content


def test_sync_custom_cursor_rules_path(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test sync with custom cursor rules path."""
    custom_rules_dir = temp_dir / "custom" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"custom-rule.mdc": "This is a custom rule."}

    create_cursor_rules(rules_data, custom_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync", "--cursor-rules-path", str(custom_rules_dir))

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{custom_rules_dir.relative_to(target_file.parent) / 'custom-rule.mdc'}" in content


def test_sync_custom_target_files(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test sync with custom target files."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target1 = temp_dir / "AI_RULES.md"
    target2 = temp_dir / "CLAUDE_RULES.md"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync", "--sync-targets", f"{target1},{target2}")

    assert result.exit_code == 0
    assert target1.exists()
    assert target2.exists()

    content1 = target1.read_text(encoding="utf-8")
    content2 = target2.read_text(encoding="utf-8")
    assert content1 == content2
    assert f"@{cursor_rules_dir.relative_to(target1.parent) / 'test-rule.mdc'}" in content1
    assert f"@{cursor_rules_dir.relative_to(target2.parent) / 'test-rule.mdc'}" in content2


def test_sync_no_cursor_rules_directory(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test sync when cursor rules directory doesn't exist."""
    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 2  # Should fail validation of path type
    # Should not create target file if no rules directory
    target_file = temp_dir / "CLAUDE.md"
    assert not target_file.exists()


def test_sync_empty_cursor_rules_directory(
    dda: CliRunner,
    temp_dir: Path,
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test sync when cursor rules directory exists but is empty."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    create_temp_file_or_dir(cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    # Should not create target file if no .mdc files
    target_file = temp_dir / "CLAUDE.md"
    assert not target_file.exists()


def test_sync_ignore_non_mdc_files(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test that sync ignores files that don't end with .mdc."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    # Create .mdc file and other files that should be ignored
    rules_data = {"valid-rule.mdc": "This is a valid rule."}
    create_cursor_rules(rules_data, cursor_rules_dir)

    # Create files that should be ignored
    ignored_file = cursor_rules_dir / "ignored.txt"
    create_temp_file_or_dir(ignored_file)
    ignored_file.write_text("This should be ignored", encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'valid-rule.mdc'}" in content
    assert "ignored.txt" not in content


def test_check_sync_in_sync(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test check sync when files are already in sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        # First sync the files
        result = dda("ai", "rules", "sync")
        assert result.exit_code == 0

        # Then check sync
        result = dda("ai", "rules", "sync", "--check-sync")
        assert result.exit_code == 0


def test_check_sync_out_of_sync(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
    create_temp_file_or_dir: Callable[[Path], None],
) -> None:
    """Test check sync when files are out of sync."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    # Create an outdated target file
    create_temp_file_or_dir(target_file)
    target_file.write_text("Old content", encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync", "--check-sync")
        assert result.exit_code == 1


def test_check_sync_missing_target_file(
    dda: CliRunner,
    temp_dir: Path,
    create_cursor_rules: Callable[[dict[str, str], Path], None],
) -> None:
    """Test check sync when target file doesn't exist."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"

    rules_data = {"test-rule.mdc": "This is a test rule."}

    create_cursor_rules(rules_data, cursor_rules_dir)

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync", "--check-sync")
        assert result.exit_code == 1


def test_sync_nested_directories(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test sync with nested rule directories."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    # Create nested structure
    nested_dir = cursor_rules_dir / "coding"
    nested_dir.mkdir(parents=True, exist_ok=True)

    rules_data = {"general.mdc": "General project rules.", "coding/typescript.mdc": "TypeScript specific rules."}

    # Create the rules manually for nested structure
    for filename, content in rules_data.items():
        rule_file = cursor_rules_dir / filename
        rule_file.parent.mkdir(parents=True, exist_ok=True)
        rule_file.write_text(content, encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'coding' / 'typescript.mdc'}" in content
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'general.mdc'}" in content


def test_sync_ignore_personal_rules(
    dda: CliRunner,
    temp_dir: Path,
) -> None:
    """Test that personal rules are ignored."""
    cursor_rules_dir = temp_dir / ".cursor" / "rules"
    target_file = temp_dir / "CLAUDE.md"

    rules_data = {"valid-rule.mdc": "This is a valid rule.", "rules/personal/my-rule.mdc": "This should be ignored."}

    # Create the rules manually for nested structure
    for filename, content in rules_data.items():
        rule_file = cursor_rules_dir / filename
        rule_file.parent.mkdir(parents=True, exist_ok=True)
        rule_file.write_text(content, encoding="utf-8")

    with temp_dir.as_cwd():
        result = dda("ai", "rules", "sync")

    assert result.exit_code == 0
    assert target_file.exists()

    content = target_file.read_text(encoding="utf-8")
    assert f"@{cursor_rules_dir.relative_to(target_file.parent) / 'valid-rule.mdc'}" in content
    assert "my-rule.mdc" not in content
