# SPDX-FileCopyrightText: 2025-present Datadog, Inc. <dev@datadoghq.com>
#
# SPDX-License-Identifier: MIT
from __future__ import annotations

import os
from typing import TYPE_CHECKING

import click

from dda.cli.base import dynamic_command, pass_app
from dda.utils.fs import Path

if TYPE_CHECKING:
    from dda.cli.application import Application


@dynamic_command(short_help="Sync cursor rules to other coding agent config file")
@click.option(
    "--cursor-rules-path",
    "-c",
    "cursor_rules_path",
    type=click.Path(exists=True, path_type=Path),
    help="Path to the cursor rules directory",
    default=".cursor/rules",
)
@click.option(
    "--sync-targets",
    "-s",
    "sync_targets",
    type=str,
    help="Comma separated list of targets files to sync the rules to. Defaults to Claude.MD file.",
    default="CLAUDE.md",
)
@click.option(
    "--check-sync",
    "-k",
    "check_sync",
    is_flag=True,
    help="Check if the rules are already in the target files, and exit 1 if they are not.",
)
@pass_app
def cmd(app: Application, *, cursor_rules_path: Path, sync_targets: str, check_sync: bool) -> None:
    cursor_rules_dir = Path(cursor_rules_path)
    targets_files = [Path(target) for target in sync_targets.split(",")]

    # Find all rule files
    rule_files = get_rule_files(cursor_rules_dir)

    if not rule_files:
        app.display_warning(f"No rule files found in {cursor_rules_dir}")
        app.display_info("Add your cursor rules files to the .cursor/rules directory and run this command again.")
        return

    app.display_info(f"Found {len(rule_files)} rule files")

    if check_sync:
        if not check_sync_status(targets_files, rule_files, cursor_rules_dir, app):
            app.abort()
        return

    sync_to_targets(targets_files, rule_files, app)


def get_rule_files(cursor_rules_dir: Path) -> list[Path]:
    """Find all rule files in cursor rules directory (recursively), excluding personal rules."""
    rule_files: list[Path] = []
    if cursor_rules_dir.is_dir():
        for root, _, files in os.walk(cursor_rules_dir):
            root_path = Path(root)
            # More robust check for personal rules using path parts
            if any(part == "personal" for part in root_path.parts):
                continue

            rule_files.extend([root_path / file for file in files if file.endswith(".mdc")])

    # Sort files for consistent output
    rule_files.sort()
    return rule_files


def generate_content(rule_files: list[Path], target_file: Path) -> str:
    """Generate the content to be written to the target file."""
    # Add header with warning and instructions
    content_parts = [
        """<!--
WARNING: This file is auto-generated by 'dda ai rules sync'
Do not edit this file manually. Instead, modify files in the .cursor/rules folder
and run 'dda ai rules sync' to update this file.
-->

# Claude AI Assistant Rules

This file contains concatenated rules from the `.cursor/rules` folder to help Claude understand the project context and coding standards.

## How to Read Metadata in Cursor Rules

Cursor rules contains the following metadata at the begnning of the file between `---` lines.
 - alwaysApply: boolean, if true, the rule will be applied to all files
 - globs: array of strings, the file globs to apply the rule to
 - description: string, a description of the rule
---

"""
    ]
    # Process each rule file
    content_parts.extend([
        f"@{rule_file.absolute().relative_to(target_file.parent.absolute(), walk_up=True)}" for rule_file in rule_files
    ])

    combined_content = "\n".join(content_parts)

    # Remove trailing separators
    return combined_content.rstrip("\n-").rstrip() + "\n"


def check_sync_status(
    targets_files: list[Path], rule_files: list[Path], cursor_rules_dir: Path, app: Application
) -> bool:
    """Check if target files are in sync with rule files. Returns True if all are in sync."""
    unsynced_targets = []
    for target_file in targets_files:
        content = generate_content(rule_files, target_file)
        if not target_file.exists() and content:
            unsynced_targets.append(str(target_file))
        else:
            app.display_info(f"Checking if {target_file} is in sync with {cursor_rules_dir}")
            target_content = target_file.read_text(encoding="utf-8")
            if target_content != content:
                app.display_error(f"Error: {target_file} is not in sync with {cursor_rules_dir}")
                unsynced_targets.append(str(target_file))

    if unsynced_targets:
        app.display_error(f"The following targets are not in sync: {', '.join(unsynced_targets)}")
        return False

    app.display_success("All targets are in sync")
    return True


def sync_to_targets(targets_files: list[Path], rule_files: list[Path], app: Application) -> None:
    """Sync rule files content to target files."""
    for target_file in targets_files:
        content = generate_content(rule_files, target_file)
        try:
            app.display_info(f"Syncing {len(rule_files)} rule files to {target_file}")
            with open(target_file, "w", encoding="utf-8") as f:
                f.write(content)

            app.display_success(f"Successfully synced {len(rule_files)} rule files to {target_file}")

        except (OSError, PermissionError, FileNotFoundError) as e:
            app.display_error(f"Error writing to {target_file}: {e}")
            app.abort()
