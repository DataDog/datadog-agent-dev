# SPDX-FileCopyrightText: 2025-present Datadog, Inc. <dev@datadoghq.com>
#
# SPDX-License-Identifier: MIT
from __future__ import annotations

import os
from typing import TYPE_CHECKING

import click
from dda.utils.diff import pretty_diff

from dda.cli.base import dynamic_command, pass_app
from dda.utils.fs import Path

if TYPE_CHECKING:
    from dda.cli.application import Application

CURSOR_RULES_DIR = Path(".cursor/rules")
TARGETS_FILES = [Path("CLAUDE.md")]

@dynamic_command(short_help="Validate AI rules are coherent between all the coding agent config files")
@click.option(
    "--fix",
    "-k",
    "should_fix",
    is_flag=True,
    help="Fix the rules if they are not coherent.",
)
@pass_app
def cmd(app: Application, *, should_fix: bool) -> None:
    cursor_rules_dir = CURSOR_RULES_DIR
    targets_files = TARGETS_FILES

    # Find all rule files
    rule_files = get_rule_files(cursor_rules_dir)

    if not rule_files:
        app.display_warning(f"No rule files found in {cursor_rules_dir}")
        app.display_info("Add your cursor rules files to the .cursor/rules directory and run this command again.")
        return

    app.display_debug(f"Found {len(rule_files)} rule files")

    unsynced_targets = []
    for target_file in targets_files:
        new_content = generate_content(rule_files, target_file)
        with open(target_file, "r", encoding="utf-8") as f:
            old_content = f.read()
            diff = pretty_diff(old_content, new_content)
            if not diff:
                continue
            app.display_info(f"Target file {target_file} is not in sync")
            app.display_info(diff)
            if should_fix:
                with open(target_file, "w", encoding="utf-8") as f:
                    f.write(new_content)
                app.display_success(f"Successfully fixed {target_file}")
            else:
                unsynced_targets.append(str(target_file))
    if unsynced_targets:
        app.display_error(f"The following targets are not in sync: {', '.join(unsynced_targets)}")
        return
    app.display_success("All targets are in sync")

def get_rule_files(cursor_rules_dir: Path) -> list[Path]:
    """Find all rule files in cursor rules directory (recursively), excluding personal rules."""
    return sorted(rule for rule in cursor_rules_dir.glob('**/*.mdc') if "personal" not in rule.parts)


def generate_content(rule_files: list[Path], target_file: Path) -> str:
    """Generate the content to be written to the target file."""
    # Add header with warning and instructions
    content_parts = [
        """<!--
WARNING: This file is auto-generated by 'dda validate ai-rules'
Do not edit this file manually. Instead, modify files in the .cursor/rules folder
and run 'dda validate ai-rules' to update this file.
-->

# AI Assistant Rules

This file contains concatenated rules from the `.cursor/rules` folder to help Claude understand the project context and coding standards.

## How to Read Metadata in Cursor Rules

Cursor rules contains the following metadata at the begnning of the file between `---` lines.
 - alwaysApply: boolean, if true, the rule will be applied to all files
 - globs: array of strings, glob patterns specifying which files to apply the rule to
 - description: string, a description of the rule
---

"""
    ]
    # Process each rule file
    content_parts.extend([
        f"@{rule_file.absolute().relative_to(target_file.parent.absolute(), walk_up=True)}" for rule_file in rule_files
    ])

    # Add CLAUDE_PERSONAL.md reference
    content_parts.append("""
# Personal rules
@CLAUDE_PERSONAL.md""")

    combined_content = "\n".join(content_parts)

    # Remove trailing separators
    return combined_content.rstrip("\n-").rstrip() + "\n"
